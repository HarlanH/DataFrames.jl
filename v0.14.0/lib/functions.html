<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · DataFrames.jl</title><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/lib/functions/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DataFrames.jl logo"/></a><h1>DataFrames.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Introduction</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/joins.html">Joins</a></li><li><a class="toctext" href="../man/split_apply_combine.html">Split-apply-combine</a></li><li><a class="toctext" href="../man/reshaping_and_pivoting.html">Reshaping</a></li><li><a class="toctext" href="../man/sorting.html">Sorting</a></li><li><a class="toctext" href="../man/categorical.html">Categorical Data</a></li><li><a class="toctext" href="../man/missing.html">Missing Data</a></li><li><a class="toctext" href="../man/querying_frameworks.html">Querying frameworks</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="types.html">Types</a></li><li class="current"><a class="toctext" href="functions.html">Functions</a><ul class="internal"><li><a class="toctext" href="#Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></li><li><a class="toctext" href="#Basics-1">Basics</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href="functions.html">Functions</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/DataFrames.jl/blob/master/docs/src/lib/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><ul><li><a href="functions.html#Base.filter"><code>Base.filter</code></a></li><li><a href="functions.html#Base.filter!"><code>Base.filter!</code></a></li><li><a href="functions.html#Base.join"><code>Base.join</code></a></li><li><a href="functions.html#Base.show"><code>Base.show</code></a></li><li><a href="functions.html#Base.sort"><code>Base.sort</code></a></li><li><a href="functions.html#Base.sort!"><code>Base.sort!</code></a></li><li><a href="functions.html#Base.unique!"><code>Base.unique!</code></a></li><li><a href="functions.html#DataFrames.aggregate"><code>DataFrames.aggregate</code></a></li><li><a href="functions.html#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a></li><li><a href="functions.html#DataFrames.by"><code>DataFrames.by</code></a></li><li><a href="functions.html#DataFrames.colwise"><code>DataFrames.colwise</code></a></li><li><a href="functions.html#DataFrames.combine"><code>DataFrames.combine</code></a></li><li><a href="functions.html#DataFrames.completecases"><code>DataFrames.completecases</code></a></li><li><a href="functions.html#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a></li><li><a href="functions.html#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a></li><li><a href="functions.html#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a></li><li><a href="functions.html#DataFrames.eachrow"><code>DataFrames.eachrow</code></a></li><li><a href="functions.html#DataFrames.eltypes"><code>DataFrames.eltypes</code></a></li><li><a href="functions.html#DataFrames.groupby"><code>DataFrames.groupby</code></a></li><li><a href="functions.html#DataFrames.head"><code>DataFrames.head</code></a></li><li><a href="functions.html#DataFrames.melt"><code>DataFrames.melt</code></a></li><li><a href="functions.html#DataFrames.meltdf"><code>DataFrames.meltdf</code></a></li><li><a href="functions.html#DataFrames.names!"><code>DataFrames.names!</code></a></li><li><a href="functions.html#DataFrames.nonunique"><code>DataFrames.nonunique</code></a></li><li><a href="functions.html#DataFrames.permutecols!"><code>DataFrames.permutecols!</code></a></li><li><a href="functions.html#DataFrames.rename"><code>DataFrames.rename</code></a></li><li><a href="functions.html#DataFrames.rename!"><code>DataFrames.rename!</code></a></li><li><a href="functions.html#DataFrames.stack"><code>DataFrames.stack</code></a></li><li><a href="functions.html#DataFrames.stackdf"><code>DataFrames.stackdf</code></a></li><li><a href="functions.html#DataFrames.tail"><code>DataFrames.tail</code></a></li><li><a href="functions.html#DataFrames.unstack"><code>DataFrames.unstack</code></a></li><li><a href="functions.html#StatsBase.describe"><code>StatsBase.describe</code></a></li></ul><h2><a class="nav-anchor" id="Grouping,-Joining,-and-Split-Apply-Combine-1" href="#Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.aggregate" href="#DataFrames.aggregate"><code>DataFrames.aggregate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Split-apply-combine that applies a set of functions over columns of an AbstractDataFrame or GroupedDataFrame</p><pre><code class="language-julia">aggregate(d::AbstractDataFrame, cols, fs)
aggregate(gd::GroupedDataFrame, fs)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame</li><li><code>gd</code> : a GroupedDataFrame</li><li><code>cols</code> : a column indicator (Symbol, Int, Vector{Symbol}, etc.)</li><li><code>fs</code> : a function or vector of functions to be applied to vectors within groups; expects each argument to be a column vector</li></ul><p>Each <code>fs</code> should return a value or vector. All returns must be the same length.</p><p><strong>Returns</strong></p><ul><li><code>::DataFrame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
               b = repeat([2, 1], outer=[4]),
               c = randn(8))
aggregate(df, :a, sum)
aggregate(df, :a, [sum, x-&gt;mean(skipmissing(x))])
aggregate(groupby(df, :a), [sum, x-&gt;mean(skipmissing(x))])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/groupeddataframe/grouping.jl#L306-L341">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.by" href="#DataFrames.by"><code>DataFrames.by</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Split-apply-combine in one step; apply <code>f</code> to each grouping in <code>d</code> based on columns <code>col</code></p><pre><code class="language-julia">by(d::AbstractDataFrame, cols, f::Function; sort::Bool = false)
by(f::Function, d::AbstractDataFrame, cols; sort::Bool = false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame</li><li><code>cols</code> : a column indicator (Symbol, Int, Vector{Symbol}, etc.)</li><li><code>f</code> : a function to be applied to groups; expects each argument to be an AbstractDataFrame</li><li><code>sort</code>: sort row groups (no sorting by default)</li></ul><p><code>f</code> can return a value, a vector, or a DataFrame. For a value or vector, these are merged into a column along with the <code>cols</code> keys. For a DataFrame, <code>cols</code> are combined along columns with the resulting DataFrame. Returning a DataFrame is the clearest because it allows column labeling.</p><p>A method is defined with <code>f</code> as the first argument, so do-block notation can be used.</p><p><code>by(d, cols, f)</code> is equivalent to <code>combine(map(f, groupby(d, cols)))</code>.</p><p><strong>Returns</strong></p><ul><li><code>::DataFrame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
               b = repeat([2, 1], outer=[4]),
               c = randn(8))
by(df, :a, d -&gt; sum(d[:c]))
by(df, :a, d -&gt; 2 * skipmissing(d[:c]))
by(df, :a, d -&gt; DataFrame(c_sum = sum(d[:c]), c_mean = mean(skipmissing(d[:c]))))
by(df, :a, d -&gt; DataFrame(c = d[:c], c_mean = mean(skipmissing(d[:c]))))
by(df, [:a, :b]) do d
    DataFrame(m = mean(skipmissing(d[:c])), v = var(skipmissing(d[:c])))
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/groupeddataframe/grouping.jl#L248-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.colwise" href="#DataFrames.colwise"><code>DataFrames.colwise</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Apply a function to each column in an AbstractDataFrame or GroupedDataFrame</p><pre><code class="language-julia">colwise(f::Function, d)
colwise(d)</code></pre><p><strong>Arguments</strong></p><ul><li><code>f</code> : a function or vector of functions</li><li><code>d</code> : an AbstractDataFrame of GroupedDataFrame</li></ul><p>If <code>d</code> is not provided, a curried version of groupby is given.</p><p><strong>Returns</strong></p><ul><li>various, depending on the call</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
               b = repeat([2, 1], outer=[4]),
               c = randn(8))
colwise(sum, df)
colwise([sum, length], df)
colwise((minimum, maximum), df)
colwise(sum, groupby(df, :a))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/groupeddataframe/grouping.jl#L209-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupby" href="#DataFrames.groupby"><code>DataFrames.groupby</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A view of an AbstractDataFrame split into row groups</p><pre><code class="language-julia">groupby(d::AbstractDataFrame, cols; sort = false, skipmissing = false)
groupby(cols; sort = false, skipmissing = false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame to split (optional, see <a href="#returns">Returns</a>)</li><li><code>cols</code> : data table columns to group by</li><li><code>sort</code>: whether to sort rows according to the values of the grouping columns <code>cols</code></li><li><code>skipmissing</code>: whether to skip rows with <code>missing</code> values in one of the grouping columns <code>cols</code></li></ul><p><strong>Returns</strong></p><ul><li><code>::GroupedDataFrame</code> : a grouped view into <code>d</code></li><li><code>::Function</code>: a function <code>x -&gt; groupby(x, cols)</code> (if <code>d</code> is not specified)</li></ul><p><strong>Details</strong></p><p>An iterator over a <code>GroupedDataFrame</code> returns a <code>SubDataFrame</code> view for each grouping into <code>d</code>. A <code>GroupedDataFrame</code> also supports indexing by groups and <code>map</code>.</p><p>See the following for additional split-apply-combine operations:</p><ul><li><code>by</code> : split-apply-combine using functions</li><li><code>aggregate</code> : split-apply-combine; applies functions in the form of a cross product</li><li><code>combine</code> : combine (obviously)</li><li><code>colwise</code> : apply a function to each column in an AbstractDataFrame or GroupedDataFrame</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
               b = repeat([2, 1], outer=[4]),
               c = randn(8))
gd = groupby(df, :a)
gd[1]
last(gd)
vcat([g[:b] for g in gd]...)
for g in gd
    println(g)
end
map(d -&gt; mean(skipmissing(d[:c])), gd)   # returns a GroupApplied object
combine(map(d -&gt; mean(skipmissing(d[:c])), gd))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/groupeddataframe/grouping.jl#L29-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join" href="#Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">join(df1, df2; on = Symbol[], kind = :inner, makeunique = false,
     indicator = nothing, validate = (false, false))</code></pre><p>Join two <code>DataFrame</code> objects</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code> : the two AbstractDataFrames to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>on</code> : A column, or vector of columns to join df1 and df2 on. If the column(s)   that df1 and df2 will be joined on have different names, then the columns   should be <code>(left, right)</code> tuples or <code>left =&gt; right</code> pairs, or a vector of   such tuples or pairs. <code>on</code> is a required argument for all joins except for   <code>kind = :cross</code></p></li><li><p><code>kind</code> : the type of join, options include:</p><ul><li><code>:inner</code> : only include rows with keys that match in both <code>df1</code> and <code>df2</code>, the default</li><li><code>:outer</code> : include all rows from <code>df1</code> and <code>df2</code></li><li><code>:left</code> : include all rows from <code>df1</code></li><li><code>:right</code> : include all rows from <code>df2</code></li><li><code>:semi</code> : return rows of <code>df1</code> that match with the keys in <code>df2</code></li><li><code>:anti</code> : return rows of <code>df1</code> that do not match with the keys in <code>df2</code></li><li><code>:cross</code> : a full Cartesian product of the key combinations; every row of <code>df1</code> is matched with every row of <code>df2</code></li></ul></li></ul><ul><li><p><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p></li><li><p><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code>, adds categorical indicator  column named <code>Symbol</code> for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>),  only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If <code>Symbol</code> is already in use,  the column name will be modified if <code>makeunique=true</code>.</p></li><li><p><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <a href="lib/@ref"><code>isequal</code></a>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</p></li></ul><p>For the three join operations that may introduce missing values (<code>:outer</code>, <code>:left</code>, and <code>:right</code>), all columns of the returned data table will support missing values.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left <code>DataFrame</code> takes precedence over the ordering of the right <code>DataFrame</code></p><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the joined DataFrame</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])

join(name, job, on = :ID)
join(name, job, on = :ID, kind = :outer)
join(name, job, on = :ID, kind = :left)
join(name, job, on = :ID, kind = :right)
join(name, job, on = :ID, kind = :semi)
join(name, job, on = :ID, kind = :anti)
join(name, job, kind = :cross)

job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
join(name, job2, on = (:ID, :identifier))
join(name, job2, on = :ID =&gt; :identifier)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/join.jl#L215-L291">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.melt" href="#DataFrames.melt"><code>DataFrames.melt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Stacks a DataFrame; convert from a wide to long format; see <code>stack</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/reshape.jl#L121-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.stack" href="#DataFrames.stack"><code>DataFrames.stack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Stacks a DataFrame; convert from a wide to long format</p><pre><code class="language-julia">stack(df::AbstractDataFrame, [measure_vars], [id_vars];
      variable_name::Symbol=:variable, value_name::Symbol=:value)
melt(df::AbstractDataFrame, [id_vars], [measure_vars];
     variable_name::Symbol=:variable, value_name::Symbol=:value)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the AbstractDataFrame to be stacked</p></li><li><p><code>measure_vars</code> : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for <code>melt</code>, defaults to all variables that are not <code>id_vars</code>. If neither <code>measure_vars</code> or <code>id_vars</code> are given, <code>measure_vars</code> defaults to all floating point columns.</p></li><li><p><code>id_vars</code> : the identifier columns that are repeated during stacking, a normal column indexing type; for <code>stack</code> defaults to all variables that are not <code>measure_vars</code></p></li><li><p><code>variable_name</code> : the name of the new stacked column that shall hold the names of each of <code>measure_vars</code></p></li><li><p><code>value_name</code> : the name of the new stacked column containing the values from each of <code>measure_vars</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the long-format DataFrame with column <code>:value</code> holding the values of the stacked columns (<code>measure_vars</code>), with column <code>:variable</code> a Vector of Symbols with the <code>measure_vars</code> name, and with columns for each of the <code>id_vars</code>.</li></ul><p>See also <code>stackdf</code> and <code>meltdf</code> for stacking methods that return a view into the original DataFrame. See <code>unstack</code> for converting from long to wide format.</p><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, &#39;a&#39;:&#39;l&#39;))

d1s = stack(d1, [:c, :d])
d1s2 = stack(d1, [:c, :d], [:a])
d1m = melt(d1, [:a, :b, :e])
d1s_name = melt(d1, [:a, :b, :e], variable_name=:somemeasure)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/reshape.jl#L16-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.unstack" href="#DataFrames.unstack"><code>DataFrames.unstack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Unstacks a DataFrame; convert from a long to wide format</p><pre><code class="language-julia">unstack(df::AbstractDataFrame, rowkeys::Union{Symbol, Integer},
        colkey::Union{Symbol, Integer}, value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame, rowkeys::AbstractVector{&lt;:Union{Symbol, Integer}},
        colkey::Union{Symbol, Integer}, value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame, colkey::Union{Symbol, Integer},
        value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the AbstractDataFrame to be unstacked</p></li><li><p><code>rowkeys</code> : the column(s) with a unique key for each row, if not given, find a key by grouping on anything not a <code>colkey</code> or <code>value</code></p></li><li><p><code>colkey</code> : the column holding the column names in wide format, defaults to <code>:variable</code></p></li><li><p><code>value</code> : the value column, defaults to <code>:value</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the wide-format DataFrame</li></ul><p>If <code>colkey</code> contains <code>missing</code> values then they will be skipped and a warning will be printed.</p><p>If combination of <code>rowkeys</code> and <code>colkey</code> contains duplicate entries then last <code>value</code> will be retained and a warning will be printed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">wide = DataFrame(id = 1:12,
                 a  = repeat([1:3;], inner = [4]),
                 b  = repeat([1:4;], inner = [3]),
                 c  = randn(12),
                 d  = randn(12))

long = stack(wide)
wide0 = unstack(long)
wide1 = unstack(long, :variable, :value)
wide2 = unstack(long, :id, :variable, :value)
wide3 = unstack(long, [:id, :a], :variable, :value)</code></pre><p>Note that there are some differences between the widened results above.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/reshape.jl#L149-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.stackdf" href="#DataFrames.stackdf"><code>DataFrames.stackdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A stacked view of a DataFrame (long format)</p><p>Like <code>stack</code> and <code>melt</code>, but a view is returned rather than data copies.</p><pre><code class="language-julia">stackdf(df::AbstractDataFrame, [measure_vars], [id_vars];
        variable_name::Symbol=:variable, value_name::Symbol=:value)
meltdf(df::AbstractDataFrame, [id_vars], [measure_vars];
       variable_name::Symbol=:variable, value_name::Symbol=:value)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the wide AbstractDataFrame</p></li><li><p><code>measure_vars</code> : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for <code>melt</code>, defaults to all variables that are not <code>id_vars</code></p></li><li><p><code>id_vars</code> : the identifier columns that are repeated during stacking, a normal column indexing type; for <code>stack</code> defaults to all variables that are not <code>measure_vars</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the long-format DataFrame with column <code>:value</code> holding the values of the stacked columns (<code>measure_vars</code>), with column <code>:variable</code> a Vector of Symbols with the <code>measure_vars</code> name, and with columns for each of the <code>id_vars</code>.</li></ul><p>The result is a view because the columns are special AbstractVectors that return indexed views into the original DataFrame.</p><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, &#39;a&#39;:&#39;l&#39;))

d1s = stackdf(d1, [:c, :d])
d1s2 = stackdf(d1, [:c, :d], [:a])
d1m = meltdf(d1, [:a, :b, :e])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/reshape.jl#L460-L510">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.meltdf" href="#DataFrames.meltdf"><code>DataFrames.meltdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A stacked view of a DataFrame (long format); see <code>stackdf</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/reshape.jl#L550-L552">source</a></section><h2><a class="nav-anchor" id="Basics-1" href="#Basics-1">Basics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.allowmissing!" href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">allowmissing!(df::DataFrame)</code></pre><p>Convert all columns of a <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><pre><code class="language-none">allowmissing!(df::DataFrame, col::Union{Integer, Symbol})</code></pre><p>Convert a single column of a <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><pre><code class="language-none">allowmissing!(df::DataFrame, cols::AbstractVector{&lt;:Union{Integer, Symbol}})</code></pre><p>Convert multiple columns of a <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/dataframe/dataframe.jl#L902-L917">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.combine" href="#DataFrames.combine"><code>DataFrames.combine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Combine a GroupApplied object (rudimentary)</p><pre><code class="language-julia">combine(ga::GroupApplied)</code></pre><p><strong>Arguments</strong></p><ul><li><code>ga</code> : a GroupApplied</li></ul><p><strong>Returns</strong></p><ul><li><code>::DataFrame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
               b = repeat([2, 1], outer=[4]),
               c = randn(8))
gd = groupby(df, :a)
combine(map(d -&gt; mean(skipmissing(d[:c])), gd))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/groupeddataframe/grouping.jl#L169-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.completecases" href="#DataFrames.completecases"><code>DataFrames.completecases</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Indexes of complete cases (rows without missing values)</p><pre><code class="language-julia">completecases(df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li></ul><p><strong>Result</strong></p><ul><li><code>::Vector{Bool}</code> : indexes of complete cases</li></ul><p>See also <a href="functions.html#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="functions.html#DataFrames.dropmissing!"><code>dropmissing!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10,
               x = Vector{Union{Missing, Float64}}(rand(10)),
               y = Vector{Union{Missing, String}}(rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10)))
df[[1,4,5], :x] = missing
df[[9,10], :y] = missing
completecases(df)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L546-L574">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.describe" href="#StatsBase.describe"><code>StatsBase.describe</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Report descriptive statistics for a data frame</p><pre><code class="language-julia">describe(df::AbstractDataFrame; stats = [:mean, :min, :median, :max, :nmissing, :nunique, :eltype])</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>stats::Union{Symbol,AbstractVector{Symbol}}</code> : the summary statistics to report. If a vector, allowed fields are <code>:mean</code>, <code>:std</code>, <code>:min</code>, <code>:q25</code>, <code>:median</code>, <code>:q75</code>, <code>:max</code>, <code>:eltype</code>, <code>:nunique</code>, <code>:first</code>, <code>:last</code>, and <code>:nmissing</code>. If set to <code>:all</code>, all summary statistics are reported.</li></ul><p><strong>Result</strong></p><ul><li>A <code>DataFrame</code> where each row represents a variable and each column a summary statistic.</li></ul><p><strong>Details</strong></p><p>For <code>Real</code> columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from <code>Real</code>, <code>describe</code> will attempt to calculate all statistics, using <code>nothing</code> as a fall-back in the case of an error.</p><p>When <code>stats</code> contains <code>:nunique</code>, <code>describe</code> will report the number of unique values in a column. If a column&#39;s base type derives from <code>Real</code>, <code>:nunique</code> will return <code>nothing</code>s.</p><p>Missing values are filtered in the calculation of all statistics, however the column <code>:nmissing</code> will report the number of missing values of that variable. If the column does not allow missing values, <code>nothing</code> is returned. Consequently, <code>nmissing = 0</code> indicates that the column allows missing values, but does not currently contain any.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
describe(df)
describe(df, stats = :all)
describe(df, stats = [:min, :max])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L380-L424">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.disallowmissing!" href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">disallowmissing!(df::DataFrame)</code></pre><p>Convert all columns of a <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><pre><code class="language-none">disallowmissing!(df::DataFrame, col::Union{Integer, Symbol})</code></pre><p>Convert a single column of a <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><pre><code class="language-none">disallowmissing!(df::DataFrame, cols::AbstractVector{&lt;:Union{Integer, Symbol}})</code></pre><p>Convert multiple columns of a <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/dataframe/dataframe.jl#L932-L947">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.dropmissing" href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Remove rows with missing values.</p><pre><code class="language-julia">dropmissing(df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated copy</li></ul><p>See also <a href="functions.html#DataFrames.completecases"><code>completecases</code></a> and <a href="functions.html#DataFrames.dropmissing!"><code>dropmissing!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10,
               x = Vector{Union{Missing, Float64}}(rand(10)),
               y = Vector{Union{Missing, String}}(rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10)))
df[[1,4,5], :x] = missing
df[[9,10], :y] = missing
dropmissing(df)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L583-L611">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.dropmissing!" href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Remove rows with missing values in-place.</p><pre><code class="language-julia">dropmissing!(df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated version</li></ul><p>See also <a href="functions.html#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="functions.html#DataFrames.completecases"><code>completecases</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10,
               x = Vector{Union{Missing, Float64}}(rand(10)),
               y = Vector{Union{Missing, String}}(rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10)))
df[[1,4,5], :x] = missing
df[[9,10], :y] = missing
dropmissing!(df)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L614-L642">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.eachrow" href="#DataFrames.eachrow"><code>DataFrames.eachrow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eachrow(df) =&gt; DataFrames.DFRowIterator</code></pre><p>Iterate a DataFrame row by row, with each row represented as a <code>DataFrameRow</code>, which is a view that acts like a one-row DataFrame.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/iteration.jl#L13-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.eltypes" href="#DataFrames.eltypes"><code>DataFrames.eltypes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return element types of columns</p><pre><code class="language-julia">eltypes(df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li></ul><p><strong>Result</strong></p><ul><li><code>::Vector{Type}</code> : the element type of each column</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
eltypes(df)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L197-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">filter(function, df::AbstractDataFrame)</code></pre><p>Return a copy of data frame <code>df</code> containing only rows for which <code>function</code> returns <code>true</code>. The function is passed a <code>DataFrameRow</code> as its only argument.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter(row -&gt; row[:x] &gt; 1, df)
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L645-L671">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter!" href="#Base.filter!"><code>Base.filter!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">filter!(function, df::AbstractDataFrame)</code></pre><p>Remove rows from data frame <code>df</code> for which <code>function</code> returns <code>false</code>. The function is passed a <code>DataFrameRow</code> as its only argument.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter!(row -&gt; row[:x] &gt; 1, df);

julia&gt; df
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L674-L702">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.head" href="#DataFrames.head"><code>DataFrames.head</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Show the first or last part of an AbstractDataFrame</p><pre><code class="language-julia">head(df::AbstractDataFrame, r::Int = 6)
tail(df::AbstractDataFrame, r::Int = 6)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>r</code> : the number of rows to show</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the first or last part of <code>df</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
head(df)
tail(df)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L312-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.names!" href="#DataFrames.names!"><code>DataFrames.names!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Set column names</p><pre><code class="language-julia">names!(df::AbstractDataFrame, vals)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>vals</code> : column names, normally a Vector{Symbol} the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
names!(df, [:a, :b, :c])
names!(df, [:a, :b, :a])  # throws ArgumentError
names!(df, [:a, :b, :a], makeunique=true)  # renames second :a to :a_1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L102-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.nonunique" href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Indexes of duplicate rows (a row that is a duplicate of a prior row)</p><pre><code class="language-julia">nonunique(df::AbstractDataFrame)
nonunique(df::AbstractDataFrame, cols)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> : a column indicator (Symbol, Int, Vector{Symbol}, etc.) specifying the column(s) to compare</li></ul><p><strong>Result</strong></p><ul><li><code>::Vector{Bool}</code> : indicates whether the row is a duplicate of some prior row</li></ul><p>See also <a href="lib/@ref"><code>unique</code></a> and <a href="functions.html#Base.unique!"><code>unique!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
df = vcat(df, df)
nonunique(df)
nonunique(df, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L730-L759">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.rename!" href="#DataFrames.rename!"><code>DataFrames.rename!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Rename columns</p><pre><code class="language-julia">rename!(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename!(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename!(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename!(f::Function, df::AbstractDataFrame)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename(f::Function, df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>d</code> : an Associative type or an AbstractArray of pairs that maps the original names to new names</li><li><code>f</code> : a function which for each column takes the old name (a Symbol) and returns the new name (a Symbol)</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p>New names are processed sequentially. A new name must not already exist in the <code>DataFrame</code> at the moment an attempt to rename a column is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
rename(df, :i =&gt; :A, :x =&gt; :X)
rename(df, [:i =&gt; :A, :x =&gt; :X])
rename(df, Dict(:i =&gt; :A, :x =&gt; :X))
rename(x -&gt; Symbol(uppercase(string(x))), df)
rename!(df, Dict(:i =&gt;: A, :x =&gt; :X))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L154-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.rename" href="#DataFrames.rename"><code>DataFrames.rename</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Rename columns</p><pre><code class="language-julia">rename!(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename!(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename!(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename!(f::Function, df::AbstractDataFrame)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename(f::Function, df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>d</code> : an Associative type or an AbstractArray of pairs that maps the original names to new names</li><li><code>f</code> : a function which for each column takes the old name (a Symbol) and returns the new name (a Symbol)</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p>New names are processed sequentially. A new name must not already exist in the <code>DataFrame</code> at the moment an attempt to rename a column is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
rename(df, :i =&gt; :A, :x =&gt; :X)
rename(df, [:i =&gt; :A, :x =&gt; :X])
rename(df, Dict(:i =&gt; :A, :x =&gt; :X))
rename(x -&gt; Symbol(uppercase(string(x))), df)
rename!(df, Dict(:i =&gt;: A, :x =&gt; :X))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L154-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show" href="#Base.show"><code>Base.show</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">show([io::IO,] df::AbstractDataFrame;
     allrows::Bool = !get(io, :limit, false),
     allcols::Bool = !get(io, :limit, false),
     allgroups::Bool = !get(io, :limit, false),
     splitcols::Bool = get(io, :limit, false),
     rowlabel::Symbol = :Row,
     summary::Bool = true)</code></pre><p>Render a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.</p><p>If <code>io</code> is omitted, the result is printed to <code>stdout</code>, and <code>allrows</code>, <code>allcols</code> and <code>allgroups</code> default to <code>false</code> while <code>splitcols</code> defaults to <code>true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li><li><code>allrows::Bool</code>: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allcols::Bool</code>: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allgroups::Bool</code>: Whether to print all groups rather than the first and last, when <code>df</code> is a <code>GroupedDataFrame</code>. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>splitcols::Bool</code>: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block. Only applies if <code>allcols</code> is <code>true</code>. By default this is the case only if <code>io</code> has the <code>IOContext</code> property <code>limit</code> set.</li><li><code>rowlabel::Symbol = :Row</code>: The label to use for the column containing row numbers.</li><li><code>summary::Bool = true</code>: Whether to print a brief string summary of the data frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; show(df, allcols=true)
3×2 DataFrame
│ Row │ A     │ B      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ x      │
│ 2   │ 2     │ y      │
│ 3   │ 3     │ z      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/show.jl#L491-L541">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort" href="#Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sort(df::AbstractDataFrame, cols;
     alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
     rev::Bool=false, order::Ordering=Forward)</code></pre><p>Return a copy of data frame <code>df</code> sorted by column(s) <code>cols</code>. <code>cols</code> can be either a <code>Symbol</code> or <code>Integer</code> column index, or a tuple or vector of such indices.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See <a href="functions.html#Base.sort!"><code>sort!</code></a> for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, (:x, :y))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, (:x, :y), rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, (:x, order(:y, rev=true)))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/sort.jl#L304-L373">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort!" href="#Base.sort!"><code>Base.sort!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sort!(df::AbstractDataFrame, cols;
      alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
      rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort data frame <code>df</code> by column(s) <code>cols</code>. <code>cols</code> can be either a <code>Symbol</code> or <code>Integer</code> column index, or a tuple or vector of such indices.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See other methods for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, (:x, :y))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, (:x, :y), rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, (:x, order(:y, rev=true)))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/dataframe/sort.jl#L2-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.tail" href="#DataFrames.tail"><code>DataFrames.tail</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Show the first or last part of an AbstractDataFrame</p><pre><code class="language-julia">head(df::AbstractDataFrame, r::Int = 6)
tail(df::AbstractDataFrame, r::Int = 6)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>r</code> : the number of rows to show</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the first or last part of <code>df</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
head(df)
tail(df)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L312-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unique!" href="#Base.unique!"><code>Base.unique!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Delete duplicate rows</p><pre><code class="language-julia">unique(df::AbstractDataFrame)
unique(df::AbstractDataFrame, cols)
unique!(df::AbstractDataFrame)
unique!(df::AbstractDataFrame, cols)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (Symbol, Int, Vector{Symbol}, etc.)</li></ul><p>specifying the column(s) to compare.</p><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated version of <code>df</code> with unique rows.</li></ul><p>When <code>cols</code> is specified, the return DataFrame contains complete rows, retaining in each case the first instance for which <code>df[cols]</code> is unique.</p><p>See also <a href="functions.html#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
df = vcat(df, df)
unique(df)   # doesn&#39;t modify df
unique(df, 1)
unique!(df)  # modifies df</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/abstractdataframe/abstractdataframe.jl#L785-L819">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.permutecols!" href="#DataFrames.permutecols!"><code>DataFrames.permutecols!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">permutecols!(df::DataFrame, p::AbstractVector)</code></pre><p>Permute the columns of <code>df</code> in-place, according to permutation <code>p</code>. Elements of <code>p</code> may be either column indices (<code>Int</code>) or names (<code>Symbol</code>), but cannot be a combination of both. All columns must be listed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(a=1:5, b=2:6, c=3:7)
5×3 DataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │
│ 2   │ 2     │ 3     │ 4     │
│ 3   │ 3     │ 4     │ 5     │
│ 4   │ 4     │ 5     │ 6     │
│ 5   │ 5     │ 6     │ 7     │

julia&gt; permutecols!(df, [2, 1, 3]);

julia&gt; df
5×3 DataFrame
│ Row │ b     │ a     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 1     │ 3     │
│ 2   │ 3     │ 2     │ 4     │
│ 3   │ 4     │ 3     │ 5     │
│ 4   │ 5     │ 4     │ 6     │
│ 5   │ 6     │ 5     │ 7     │

julia&gt; permutecols!(df, [:c, :a, :b]);

julia&gt; df
5×3 DataFrame
│ Row │ c     │ a     │ b     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 1     │ 2     │
│ 2   │ 4     │ 2     │ 3     │
│ 3   │ 5     │ 3     │ 4     │
│ 4   │ 6     │ 4     │ 5     │
│ 5   │ 7     │ 5     │ 6     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/b02ad3c94a3c8f149bab83f44f6d2e54db475c34/src/dataframe/dataframe.jl#L1073-L1120">source</a></section><footer><hr/><a class="previous" href="types.html"><span class="direction">Previous</span><span class="title">Types</span></a></footer></article></body></html>
