<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · DataFrames.jl</title><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/lib/functions/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><h1>DataFrames.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/joins/">Joins</a></li><li><a class="toctext" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="toctext" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="toctext" href="../../man/sorting/">Sorting</a></li><li><a class="toctext" href="../../man/categorical/">Categorical Data</a></li><li><a class="toctext" href="../../man/missing/">Missing Data</a></li><li><a class="toctext" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../types/">Types</a></li><li class="current"><a class="toctext" href>Functions</a><ul class="internal"><li><a class="toctext" href="#Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></li><li><a class="toctext" href="#Basics-1">Basics</a></li></ul></li><li><a class="toctext" href="../indexing/">Indexing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href>Functions</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/DataFrames.jl/blob/master/docs/src/lib/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><ul><li><a href="#Base.append!"><code>Base.append!</code></a></li><li><a href="#Base.copy"><code>Base.copy</code></a></li><li><a href="#Base.filter"><code>Base.filter</code></a></li><li><a href="#Base.filter!"><code>Base.filter!</code></a></li><li><a href="#Base.hcat"><code>Base.hcat</code></a></li><li><a href="#Base.join"><code>Base.join</code></a></li><li><a href="#Base.map"><code>Base.map</code></a></li><li><a href="#Base.push!"><code>Base.push!</code></a></li><li><a href="#Base.repeat"><code>Base.repeat</code></a></li><li><a href="#Base.show"><code>Base.show</code></a></li><li><a href="#Base.sort"><code>Base.sort</code></a></li><li><a href="#Base.sort!"><code>Base.sort!</code></a></li><li><a href="#Base.unique!"><code>Base.unique!</code></a></li><li><a href="#Base.vcat"><code>Base.vcat</code></a></li><li><a href="#CategoricalArrays.categorical"><code>CategoricalArrays.categorical</code></a></li><li><a href="#DataAPI.describe"><code>DataAPI.describe</code></a></li><li><a href="#DataFrames.DataFrame!"><code>DataFrames.DataFrame!</code></a></li><li><a href="#DataFrames.aggregate"><code>DataFrames.aggregate</code></a></li><li><a href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a></li><li><a href="#DataFrames.by"><code>DataFrames.by</code></a></li><li><a href="#DataFrames.categorical!"><code>DataFrames.categorical!</code></a></li><li><a href="#DataFrames.combine"><code>DataFrames.combine</code></a></li><li><a href="#DataFrames.completecases"><code>DataFrames.completecases</code></a></li><li><a href="#DataFrames.deleterows!"><code>DataFrames.deleterows!</code></a></li><li><a href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a></li><li><a href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a></li><li><a href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a></li><li><a href="#DataFrames.eachcol"><code>DataFrames.eachcol</code></a></li><li><a href="#DataFrames.eachrow"><code>DataFrames.eachrow</code></a></li><li><a href="#DataFrames.eltypes"><code>DataFrames.eltypes</code></a></li><li><a href="#DataFrames.groupby"><code>DataFrames.groupby</code></a></li><li><a href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a></li><li><a href="#DataFrames.groupvars"><code>DataFrames.groupvars</code></a></li><li><a href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a></li><li><a href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a></li><li><a href="#DataFrames.melt"><code>DataFrames.melt</code></a></li><li><a href="#DataFrames.meltdf"><code>DataFrames.meltdf</code></a></li><li><a href="#DataFrames.names!"><code>DataFrames.names!</code></a></li><li><a href="#DataFrames.ncol"><code>DataFrames.ncol</code></a></li><li><a href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a></li><li><a href="#DataFrames.nrow"><code>DataFrames.nrow</code></a></li><li><a href="#DataFrames.permutecols!"><code>DataFrames.permutecols!</code></a></li><li><a href="#DataFrames.rename"><code>DataFrames.rename</code></a></li><li><a href="#DataFrames.rename!"><code>DataFrames.rename!</code></a></li><li><a href="#DataFrames.select"><code>DataFrames.select</code></a></li><li><a href="#DataFrames.select!"><code>DataFrames.select!</code></a></li><li><a href="#DataFrames.stack"><code>DataFrames.stack</code></a></li><li><a href="#DataFrames.stackdf"><code>DataFrames.stackdf</code></a></li><li><a href="#DataFrames.unstack"><code>DataFrames.unstack</code></a></li><li><a href="#Missings.allowmissing"><code>Missings.allowmissing</code></a></li><li><a href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a></li></ul><h2><a class="nav-anchor" id="Grouping,-Joining,-and-Split-Apply-Combine-1" href="#Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.aggregate" href="#DataFrames.aggregate"><code>DataFrames.aggregate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Split-apply-combine that applies a set of functions over columns of an <code>AbstractDataFrame</code> or <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a></p><pre><code class="language-julia">aggregate(df::AbstractDataFrame, cols, fs)
aggregate(gd::GroupedDataFrame, fs)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code></li><li><code>gd</code> : a <code>GroupedDataFrame</code></li><li><code>cols</code> : a column indicator (<code>Symbol</code>, <code>Int</code>, <code>Vector{Symbol}</code>, etc.)</li><li><code>fs</code> : a function or vector of functions to be applied to vectors within groups; expects each argument to be a column vector</li></ul><p>Each <code>fs</code> should return a value or vector. All returns must be the same length.</p><p><strong>Returns</strong></p><ul><li><code>::DataFrame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Statistics

julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; aggregate(df, :a, sum)
4×3 DataFrame
│ Row │ a     │ b_sum │ c_sum │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 4     │ 6     │
│ 2   │ 2     │ 2     │ 8     │
│ 3   │ 3     │ 4     │ 10    │
│ 4   │ 4     │ 2     │ 12    │

julia&gt; aggregate(df, :a, [sum, x-&gt;mean(skipmissing(x))])
4×5 DataFrame
│ Row │ a     │ b_sum │ c_sum │ b_function │ c_function │
│     │ Int64 │ Int64 │ Int64 │ Float64    │ Float64    │
├─────┼───────┼───────┼───────┼────────────┼────────────┤
│ 1   │ 1     │ 4     │ 6     │ 2.0        │ 3.0        │
│ 2   │ 2     │ 2     │ 8     │ 1.0        │ 4.0        │
│ 3   │ 3     │ 4     │ 10    │ 2.0        │ 5.0        │
│ 4   │ 4     │ 2     │ 12    │ 1.0        │ 6.0        │

julia&gt; aggregate(groupby(df, :a), [sum, x-&gt;mean(skipmissing(x))])
4×5 DataFrame
│ Row │ a     │ b_sum │ c_sum │ b_function │ c_function │
│     │ Int64 │ Int64 │ Int64 │ Float64    │ Float64    │
├─────┼───────┼───────┼───────┼────────────┼────────────┤
│ 1   │ 1     │ 4     │ 6     │ 2.0        │ 3.0        │
│ 2   │ 2     │ 2     │ 8     │ 1.0        │ 4.0        │
│ 3   │ 3     │ 4     │ 10    │ 2.0        │ 5.0        │
│ 4   │ 4     │ 2     │ 12    │ 1.0        │ 6.0        │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/groupeddataframe/grouping.jl#L1083-L1146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.by" href="#DataFrames.by"><code>DataFrames.by</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">by(df::AbstractDataFrame, keys, cols =&gt; f...; sort::Bool = false)
by(df::AbstractDataFrame, keys; (colname = cols =&gt; f)..., sort::Bool = false)
by(df::AbstractDataFrame, keys, f; sort::Bool = false)
by(f, df::AbstractDataFrame, keys; sort::Bool = false)</code></pre><p>Split-apply-combine in one step: apply <code>f</code> to each grouping in <code>df</code> based on grouping columns <code>keys</code>, and return a <code>DataFrame</code>.</p><p><code>keys</code> can be either a single column index, or a vector thereof.</p><p>If the last argument(s) consist(s) in one or more <code>cols =&gt; f</code> pair(s), or if <code>colname = cols =&gt; f</code> keyword arguments are provided, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the last argument is a callable <code>f</code>, it is passed a <a href="../types/#DataFrames.SubDataFrame"><code>SubDataFrame</code></a> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability. A method is defined with <code>f</code> as the first argument, so do-block notation can be used.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p><code>f</code> must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>As a special case, if multiple pairs are passed as last arguments, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting data frame contains all the grouping columns in addition to those generated by the application of <code>f</code>. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input colummn name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on. The resulting data frame will be sorted on <code>keys</code> if <code>sort=true</code>. Otherwise, ordering of rows is undefined.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length) are specified using the pair syntax (e.g.</code>col =&gt; sum<code>). When computing the</code>sum<code>or</code>mean<code>over floating point columns, results will be less accurate than the standard [</code>sum<code>](@ref) function (which uses pairwise summation). Use</code>col =&gt; x -&gt; sum(x)` to avoid the optimized method and use the slower, more accurate one.</p><p><code>by(d, cols, f)</code> is equivalent to <code>combine(f, groupby(d, cols))</code> and to the less efficient <code>combine(map(f, groupby(d, cols)))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; by(df, :a, :c =&gt; sum)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a, d -&gt; sum(d.c)) # Slower variant
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a) do d # do syntax for the slower variant
           sum(d.c)
       end
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a, :c =&gt; x -&gt; 2 .* x)
8×2 DataFrame
│ Row │ a     │ c_function │
│     │ Int64 │ Int64      │
├─────┼───────┼────────────┤
│ 1   │ 1     │ 2          │
│ 2   │ 1     │ 10         │
│ 3   │ 2     │ 4          │
│ 4   │ 2     │ 12         │
│ 5   │ 3     │ 6          │
│ 6   │ 3     │ 14         │
│ 7   │ 4     │ 8          │
│ 8   │ 4     │ 16         │

julia&gt; by(df, :a, c_sum = :c =&gt; sum, c_sum2 = :c =&gt; x -&gt; sum(x.^2))
4×3 DataFrame
│ Row │ a     │ c_sum │ c_sum2 │
│     │ Int64 │ Int64 │ Int64  │
├─────┼───────┼───────┼────────┤
│ 1   │ 1     │ 6     │ 26     │
│ 2   │ 2     │ 8     │ 40     │
│ 3   │ 3     │ 10    │ 58     │
│ 4   │ 4     │ 12    │ 80     │

julia&gt; by(df, :a, (:b, :c) =&gt; x -&gt; (minb = minimum(x.b), sumc = sum(x.c)))
4×3 DataFrame
│ Row │ a     │ minb  │ sumc  │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 6     │
│ 2   │ 2     │ 1     │ 8     │
│ 3   │ 3     │ 2     │ 10    │
│ 4   │ 4     │ 1     │ 12    │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/groupeddataframe/grouping.jl#L930-L1066">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.combine" href="#DataFrames.combine"><code>DataFrames.combine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">combine(gd::GroupedDataFrame, cols =&gt; f...)
combine(gd::GroupedDataFrame; (colname = cols =&gt; f)...)
combine(gd::GroupedDataFrame, f)
combine(f, gd::GroupedDataFrame)</code></pre><p>Transform a <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a> into a <code>DataFrame</code>.</p><p>If the last argument(s) consist(s) in one or more <code>cols =&gt; f</code> pair(s), or if <code>colname = cols =&gt; f</code> keyword arguments are provided, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the last argument is a callable <code>f</code>, it is passed a <a href="../types/#DataFrames.SubDataFrame"><code>SubDataFrame</code></a> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability. A method is defined with <code>f</code> as the first argument, so do-block notation can be used.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p><code>f</code> must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>As a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting data frame contains all the grouping columns in addition to those generated by the application of <code>f</code>. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on. The resulting data frame will be sorted if <code>sort=true</code> was passed to the <a href="#DataFrames.groupby"><code>groupby</code></a> call from which <code>gd</code> was constructed. Otherwise, ordering of rows is undefined.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length</code>) are specified using the pair syntax (e.g. <code>col =&gt; sum</code>). When computing the <code>sum</code> or <code>mean</code> over floating point columns, results will be less accurate than the standard <a href="lib/@ref"><code>sum</code></a> function (which uses pairwise summation). Use <code>col =&gt; x -&gt; sum(x)</code> to avoid the optimized method and use the slower, more accurate one.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :c =&gt; sum)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(:c =&gt; sum, gd)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(df -&gt; sum(df.c), gd) # Slower variant
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │</code></pre><p>See <a href="#DataFrames.by"><code>by</code></a> for more examples.</p><p><strong>See also</strong></p><p><a href="#DataFrames.by"><code>by(f, df, cols)</code></a> is a shorthand for <code>combine(f, groupby(df, cols))</code>.</p><p><a href="#Base.map"><code>map</code></a>: <code>combine(f, groupby(df, cols))</code> is a more efficient equivalent of <code>combine(map(f, groupby(df, cols)))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/groupeddataframe/grouping.jl#L328-L434">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupby" href="#DataFrames.groupby"><code>DataFrames.groupby</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A view of an <code>AbstractDataFrame</code> split into row groups</p><pre><code class="language-julia">groupby(d::AbstractDataFrame, cols; sort = false, skipmissing = false)
groupby(cols; sort = false, skipmissing = false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code> to split (optional, see <a href="#returns">Returns</a>)</li><li><code>cols</code> : data table columns to group by</li><li><code>sort</code> : whether to sort rows according to the values of the grouping columns <code>cols</code></li><li><code>skipmissing</code> : whether to skip rows with <code>missing</code> values in one of the grouping columns <code>cols</code></li></ul><p><strong>Returns</strong></p><p>A <code>GroupedDataFrame</code> : a grouped view into <code>df</code></p><p><strong>Details</strong></p><p>An iterator over a <code>GroupedDataFrame</code> returns a <code>SubDataFrame</code> view for each grouping into <code>df</code>. Within each group, the order of rows in <code>df</code> is preserved.</p><p>A <code>GroupedDataFrame</code> also supports indexing by groups, <code>map</code> (which applies a function to each group) and <code>combine</code> (which applies a function to each group and combines the result into a data frame).</p><p>See the following for additional split-apply-combine operations:</p><ul><li><code>by</code> : split-apply-combine using functions</li><li><code>aggregate</code> : split-apply-combine; applies functions in the form of a cross product</li><li><code>map</code> : apply a function to each group of a <code>GroupedDataFrame</code> (without combining)</li><li><code>combine</code> : combine a <code>GroupedDataFrame</code>, optionally applying a function to each group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 4 groups based on key: a
First Group (2 rows): a = 1
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │
⋮
Last Group (2 rows): a = 4
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │

julia&gt; gd[1]
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │

julia&gt; last(gd)
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │

julia&gt; for g in gd
           println(g)
       end
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 1     │ 2     │
│ 2   │ 2     │ 1     │ 6     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 2     │ 3     │
│ 2   │ 3     │ 2     │ 7     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/groupeddataframe/grouping.jl#L32-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupindices" href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">groupindices(gd::GroupedDataFrame)</code></pre><p>Return a vector of group indices for each row of <code>parent(gd)</code>.</p><p>Rows appearing in group <code>gd[i]</code> are attributed index <code>i</code>. Rows not present in any group are attributed <code>missing</code> (this can happen if <code>skipmissing=true</code> was passed when creating <code>gd</code>, or if <code>gd</code> is a subset from a larger <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/groupeddataframe/grouping.jl#L1203-L1211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupvars" href="#DataFrames.groupvars"><code>DataFrames.groupvars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">groupvars(gd::GroupedDataFrame)</code></pre><p>Return a vector of column names in <code>parent(gd)</code> used for grouping.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/groupeddataframe/grouping.jl#L1214-L1218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join" href="#Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">join(df1, df2; on = Symbol[], kind = :inner, makeunique = false,
     indicator = nothing, validate = (false, false))</code></pre><p>Join two <code>DataFrame</code> objects</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code> : the two AbstractDataFrames to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>on</code> : A column, or vector of columns to join df1 and df2 on. If the column(s)   that df1 and df2 will be joined on have different names, then the columns   should be <code>left =&gt; right</code> pairs, or a vector of such pairs.   <code>on</code> is a required argument for all joins except for <code>kind = :cross</code></p></li><li><p><code>kind</code> : the type of join, options include:</p><ul><li><code>:inner</code> : only include rows with keys that match in both <code>df1</code> and <code>df2</code>, the default</li><li><code>:outer</code> : include all rows from <code>df1</code> and <code>df2</code></li><li><code>:left</code> : include all rows from <code>df1</code></li><li><code>:right</code> : include all rows from <code>df2</code></li><li><code>:semi</code> : return rows of <code>df1</code> that match with the keys in <code>df2</code></li><li><code>:anti</code> : return rows of <code>df1</code> that do not match with the keys in <code>df2</code></li><li><code>:cross</code> : a full Cartesian product of the key combinations; every row of <code>df1</code> is matched with every row of <code>df2</code></li></ul></li></ul><ul><li><p><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p></li><li><p><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code>, adds categorical indicator  column named <code>Symbol</code> for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>),  only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If <code>Symbol</code> is already in use,  the column name will be modified if <code>makeunique=true</code>.</p></li><li><p><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <a href="lib/@ref"><code>isequal</code></a>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</p></li></ul><p>For the three join operations that may introduce missing values (<code>:outer</code>, <code>:left</code>, and <code>:right</code>), all columns of the returned data table will support missing values.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left <code>DataFrame</code> takes precedence over the ordering of the right <code>DataFrame</code></p><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the joined DataFrame</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])

join(name, job, on = :ID)
join(name, job, on = :ID, kind = :outer)
join(name, job, on = :ID, kind = :left)
join(name, job, on = :ID, kind = :right)
join(name, job, on = :ID, kind = :semi)
join(name, job, on = :ID, kind = :anti)
join(name, job, kind = :cross)

job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
join(name, job2, on = :ID =&gt; :identifier)
join(name, job2, on = [:ID =&gt; :identifier])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/join.jl#L216-L291">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map" href="#Base.map"><code>Base.map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">map(cols =&gt; f, gd::GroupedDataFrame)
map(f, gd::GroupedDataFrame)</code></pre><p>Apply a function to each group of rows and return a <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>.</p><p>If the first argument is a <code>cols =&gt; f</code> pair, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the first argument is a vector, tuple or named tuple of such pairs, each pair is handled as described above. If a named tuple, field names are used to name each generated column.</p><p>If the first argument is a callable, it is passed a <code>SubDataFrame</code> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p><code>f</code> must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>As a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting <code>GroupedDataFrame</code> contains all the grouping columns in addition to those generated by the application of <code>f</code>. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length</code>) are specified using the pair syntax (e.g. <code>col =&gt; sum</code>). When computing the <code>sum</code> or <code>mean</code> over floating point columns, results will be less accurate than the standard <a href="lib/@ref"><code>sum</code></a> function (which uses pairwise summation). Use <code>col =&gt; x -&gt; sum(x)</code> to avoid the optimized method and use the slower, more accurate one.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; map(:c =&gt; sum, gd)
GroupedDataFrame{DataFrame} with 4 groups based on key: :a
First Group: 1 row
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
⋮
Last Group: 1 row
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 4     │ 12    │

julia&gt; map(df -&gt; sum(df.c), gd) # Slower variant
GroupedDataFrame{DataFrame} with 4 groups based on key: :a
First Group: 1 row
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
⋮
Last Group: 1 row
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 4     │ 12    │</code></pre><p>See <a href="#DataFrames.by"><code>by</code></a> for more examples.</p><p><strong>See also</strong></p><p><code>combine(f, gd)</code> returns a <code>DataFrame</code> rather than a <code>GroupedDataFrame</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/groupeddataframe/grouping.jl#L200-L296">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.melt" href="#DataFrames.melt"><code>DataFrames.melt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Stacks a DataFrame; convert from a wide to long format; see <code>stack</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/reshape.jl#L121-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.stack" href="#DataFrames.stack"><code>DataFrames.stack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Stacks a DataFrame; convert from a wide to long format</p><pre><code class="language-julia">stack(df::AbstractDataFrame, [measure_vars], [id_vars];
      variable_name::Symbol=:variable, value_name::Symbol=:value)
melt(df::AbstractDataFrame, [id_vars], [measure_vars];
     variable_name::Symbol=:variable, value_name::Symbol=:value)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the AbstractDataFrame to be stacked</p></li><li><p><code>measure_vars</code> : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for <code>melt</code>, defaults to all variables that are not <code>id_vars</code>. If neither <code>measure_vars</code> or <code>id_vars</code> are given, <code>measure_vars</code> defaults to all floating point columns.</p></li><li><p><code>id_vars</code> : the identifier columns that are repeated during stacking, a normal column indexing type; for <code>stack</code> defaults to all variables that are not <code>measure_vars</code></p></li><li><p><code>variable_name</code> : the name of the new stacked column that shall hold the names of each of <code>measure_vars</code></p></li><li><p><code>value_name</code> : the name of the new stacked column containing the values from each of <code>measure_vars</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the long-format DataFrame with column <code>:value</code> holding the values of the stacked columns (<code>measure_vars</code>), with column <code>:variable</code> a Vector of Symbols with the <code>measure_vars</code> name, and with columns for each of the <code>id_vars</code>.</li></ul><p>See also <code>stackdf</code> and <code>meltdf</code> for stacking methods that return a view into the original DataFrame. See <code>unstack</code> for converting from long to wide format.</p><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, &#39;a&#39;:&#39;l&#39;))

d1s = stack(d1, [:c, :d])
d1s2 = stack(d1, [:c, :d], [:a])
d1m = melt(d1, [:a, :b, :e])
d1s_name = melt(d1, [:a, :b, :e], variable_name=:somemeasure)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/reshape.jl#L16-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.unstack" href="#DataFrames.unstack"><code>DataFrames.unstack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Unstacks a DataFrame; convert from a long to wide format</p><pre><code class="language-julia">unstack(df::AbstractDataFrame, rowkeys::Union{Integer, Symbol},
        colkey::Union{Integer, Symbol}, value::Union{Integer, Symbol};
        renamecols::Function=identity)
unstack(df::AbstractDataFrame, rowkeys::AbstractVector{&lt;:Union{Integer, Symbol}},
        colkey::Union{Integer, Symbol}, value::Union{Integer, Symbol};
        renamecols::Function=identity)
unstack(df::AbstractDataFrame, colkey::Union{Integer, Symbol},
        value::Union{Integer, Symbol}; renamecols::Function=identity)
unstack(df::AbstractDataFrame; renamecols::Function=identity)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the AbstractDataFrame to be unstacked</p></li><li><p><code>rowkeys</code> : the column(s) with a unique key for each row, if not given, find a key by grouping on anything not a <code>colkey</code> or <code>value</code></p></li><li><p><code>colkey</code> : the column holding the column names in wide format, defaults to <code>:variable</code></p></li><li><p><code>value</code> : the value column, defaults to <code>:value</code></p></li><li><p><code>renamecols</code> : a function called on each unique value in <code>colkey</code> which must                return the name of the column to be created (typically as a string                or a <code>Symbol</code>). Duplicate names are not allowed.</p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the wide-format DataFrame</li></ul><p>If <code>colkey</code> contains <code>missing</code> values then they will be skipped and a warning will be printed.</p><p>If combination of <code>rowkeys</code> and <code>colkey</code> contains duplicate entries then last <code>value</code> will be retained and a warning will be printed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">wide = DataFrame(id = 1:12,
                 a  = repeat([1:3;], inner = [4]),
                 b  = repeat([1:4;], inner = [3]),
                 c  = randn(12),
                 d  = randn(12))

long = stack(wide)
wide0 = unstack(long)
wide1 = unstack(long, :variable, :value)
wide2 = unstack(long, :id, :variable, :value)
wide3 = unstack(long, [:id, :a], :variable, :value)
wide4 = unstack(long, :id, :variable, :value, renamecols=x-&gt;Symbol(:_, x))</code></pre><p>Note that there are some differences between the widened results above.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/reshape.jl#L149-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.stackdf" href="#DataFrames.stackdf"><code>DataFrames.stackdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A stacked view of a DataFrame (long format)</p><p>Like <code>stack</code> and <code>melt</code>, but a view is returned rather than data copies.</p><pre><code class="language-julia">stackdf(df::AbstractDataFrame, [measure_vars], [id_vars];
        variable_name::Symbol=:variable, value_name::Symbol=:value)
meltdf(df::AbstractDataFrame, [id_vars], [measure_vars];
       variable_name::Symbol=:variable, value_name::Symbol=:value)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the wide AbstractDataFrame</p></li><li><p><code>measure_vars</code> : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for <code>melt</code>, defaults to all variables that are not <code>id_vars</code></p></li><li><p><code>id_vars</code> : the identifier columns that are repeated during stacking, a normal column indexing type; for <code>stack</code> defaults to all variables that are not <code>measure_vars</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the long-format DataFrame with column <code>:value</code> holding the values of the stacked columns (<code>measure_vars</code>), with column <code>:variable</code> a Vector of Symbols with the <code>measure_vars</code> name, and with columns for each of the <code>id_vars</code>.</li></ul><p>The result is a view because the columns are special AbstractVectors that return indexed views into the original DataFrame.</p><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, &#39;a&#39;:&#39;l&#39;))

d1s = stackdf(d1, [:c, :d])
d1s2 = stackdf(d1, [:c, :d], [:a])
d1m = meltdf(d1, [:a, :b, :e])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/reshape.jl#L475-L525">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.meltdf" href="#DataFrames.meltdf"><code>DataFrames.meltdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A stacked view of a DataFrame (long format); see <code>stackdf</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/reshape.jl#L565-L567">source</a></section><h2><a class="nav-anchor" id="Basics-1" href="#Basics-1">Basics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Missings.allowmissing" href="#Missings.allowmissing"><code>Missings.allowmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">allowmissing(df::AbstractDataFrame,
             cols::Union{ColumnIndex, AbstractVector, Regex, Not, Between, All, Colon}=:)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted to element type <code>Union{T, Missing}</code> from <code>T</code> to allow support for missing values.</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=[1,2])
2×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │

julia&gt; allowmissing(df)
2×1 DataFrame
│ Row │ a      │
│     │ Int64⍰ │
├─────┼────────┤
│ 1   │ 1      │
│ 2   │ 2      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L1317-L1345">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.allowmissing!" href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">allowmissing!(df::DataFrame, cols::Colon=:)
allowmissing!(df::DataFrame, cols::Union{Integer, Symbol})
allowmissing!(df::DataFrame, cols::Union{AbstractVector, Regex, Not, Between, All})</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L886-L895">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CategoricalArrays.categorical" href="#CategoricalArrays.categorical"><code>CategoricalArrays.categorical</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">categorical(df::AbstractDataFrame, cols::Type=Union{AbstractString, Missing};
            compress::Bool=false)
categorical(df::AbstractDataFrame,
            cols::Union{ColumnIndex, AbstractVector, Regex, Not, Between, All, Colon};
            compress::Bool=false)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted to <code>CategoricalVector</code>. If <code>categorical</code> is called with the <code>cols</code> argument being a <code>Type</code>, then all columns whose element type is a subtype of this type (by default <code>Union{AbstractString, Missing}</code>) will be converted to categorical.</p><p>If the <code>compress</code> keyword argument is set to <code>true</code> then the created <code>CategoricalVector</code>s will be compressed.</p><p>All created <code>CategoricalVector</code>s are unordered.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=[1,2], b=[&quot;a&quot;,&quot;b&quot;])
2×2 DataFrame
│ Row │ a     │ b      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ a      │
│ 2   │ 2     │ b      │

julia&gt; categorical(df)
2×2 DataFrame
│ Row │ a     │ b            │
│     │ Int64 │ Categorical… │
├─────┼───────┼──────────────┤
│ 1   │ 1     │ a            │
│ 2   │ 2     │ b            │

julia&gt; categorical(df, :)
2×2 DataFrame
│ Row │ a            │ b            │
│     │ Categorical… │ Categorical… │
├─────┼──────────────┼──────────────┤
│ 1   │ 1            │ a            │
│ 2   │ 2            │ b            │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L1362-L1407">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.categorical!" href="#DataFrames.categorical!"><code>DataFrames.categorical!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">categorical!(df::DataFrame, cols::Type=Union{AbstractString, Missing};
             compress::Bool=false)
categorical!(df::DataFrame, cname::Union{Integer, Symbol};
             compress::Bool=false)
categorical!(df::DataFrame, cnames::Vector{&lt;:Union{Integer, Symbol}};
             compress::Bool=false)
categorical!(df::DataFrame, cnames::Union{Regex, Not, Between, All};
             compress::Bool=false)</code></pre><p>Change columns selected by <code>cname</code> or <code>cnames</code> in data frame <code>df</code> to <code>CategoricalVector</code>.</p><p>If <code>categorical!</code> is called with the <code>cols</code> argument being a <code>Type</code>, then all columns whose element type is a subtype of this type (by default <code>Union{AbstractString, Missing}</code>) will be converted to categorical.</p><p>If the <code>compress</code> keyword argument is set to <code>true</code> then the created <code>CategoricalVector</code>s will be compressed.</p><p>All created <code>CategoricalVector</code>s are unordered.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(X=[&quot;a&quot;, &quot;b&quot;], Y=[1, 2], Z=[&quot;p&quot;, &quot;q&quot;])
2×3 DataFrame
│ Row │ X      │ Y     │ Z      │
│     │ String │ Int64 │ String │
├─────┼────────┼───────┼────────┤
│ 1   │ a      │ 1     │ p      │
│ 2   │ b      │ 2     │ q      │

julia&gt; categorical!(df)
2×3 DataFrame
│ Row │ X            │ Y     │ Z            │
│     │ Categorical… │ Int64 │ Categorical… │
├─────┼──────────────┼───────┼──────────────┤
│ 1   │ a            │ 1     │ p            │
│ 2   │ b            │ 2     │ q            │

julia&gt; eltypes(df)
3-element Array{DataType,1}:
 CategoricalString{UInt32}
 Int64
 CategoricalString{UInt32}

julia&gt; df = DataFrame(X=[&quot;a&quot;, &quot;b&quot;], Y=[1, 2], Z=[&quot;p&quot;, &quot;q&quot;])
2×3 DataFrame
│ Row │ X      │ Y     │ Z      │
│     │ String │ Int64 │ String │
├─────┼────────┼───────┼────────┤
│ 1   │ a      │ 1     │ p      │
│ 2   │ b      │ 2     │ q      │

julia&gt; categorical!(df, :Y, compress=true)
2×3 DataFrame
│ Row │ X      │ Y            │ Z      │
│     │ String │ Categorical… │ String │
├─────┼────────┼──────────────┼────────┤
│ 1   │ a      │ 1            │ p      │
│ 2   │ b      │ 2            │ q      │

julia&gt; eltypes(df)
3-element Array{DataType,1}:
 String
 CategoricalValue{Int64,UInt8}
 String</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L968-L1037">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.completecases" href="#DataFrames.completecases"><code>DataFrames.completecases</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">completecases(df::AbstractDataFrame, cols::Colon=:)
completecases(df::AbstractDataFrame, cols::Union{AbstractVector, Regex, Not, Between, All})
completecases(df::AbstractDataFrame, cols::Union{Integer, Symbol})</code></pre><p>Return a Boolean vector with <code>true</code> entries indicating rows without missing values (complete cases) in data frame <code>df</code>. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>. Use <code>findall(completecases(df))</code> to get the indices of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; completecases(df)
5-element BitArray{1}:
 false
 false
 false
  true
  true

julia&gt; completecases(df, :x)
5-element BitArray{1}:
 false
  true
 false
  true
  true

julia&gt; completecases(df, [:x, :y])
5-element BitArray{1}:
 false
 false
 false
  true
  true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L511-L564">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">copy(df::DataFrame; copycols::Bool=true)</code></pre><p>Copy data frame <code>df</code>. If <code>copycols=true</code> (the default), return a new  <code>DataFrame</code> holding copies of column vectors in <code>df</code>. If <code>copycols=false</code>, return a new <code>DataFrame</code> sharing column vectors with <code>df</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L656-L663">source</a><div><div><pre><code class="language-none">copy(dfr::DataFrameRow)</code></pre><p>Convert a <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> to a <code>NamedTuple</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframerow/dataframerow.jl#L178-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.DataFrame!" href="#DataFrames.DataFrame!"><code>DataFrames.DataFrame!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">DataFrame!(args...; kwargs...)</code></pre><p>Equivalent to <code>DataFrame(args...; copycols=false, kwargs...)</code>.</p><p>If <code>kwargs</code> contains the <code>copycols</code> keyword argument an error is thrown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(a=1:3)
3×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │

julia&gt; df2 = DataFrame!(df1)

julia&gt; df1.a === df2.a
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L223-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.deleterows!" href="#DataFrames.deleterows!"><code>DataFrames.deleterows!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">deleterows!(df::DataFrame, inds)</code></pre><p>Delete rows specified by <code>inds</code> from a <code>DataFrame</code> <code>df</code> in place and return it.</p><p>Internally <code>deleteat!</code> is called for all columns so <code>inds</code> must be: a vector of sorted and unique integers, a boolean vector or an integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; deleterows!(d, 2)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 3     │ 6     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L672-L701">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAPI.describe" href="#DataAPI.describe"><code>DataAPI.describe</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Report descriptive statistics for a data frame</p><pre><code class="language-julia">describe(df::AbstractDataFrame)
describe(df::AbstractDataFrame, stats::Union{Symbol, Pair{&lt;:Symbol}}...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>stats::Union{Symbol, Pair{&lt;:Symbol}}...</code> : the summary statistics to report. Arguments can be:<ul><li>A symbol from the list <code>:mean</code>, <code>:std</code>, <code>:min</code>, <code>:q25</code>, <code>:median</code>, <code>:q75</code>, <code>:max</code>, <code>:eltype</code>, <code>:nunique</code>, <code>:first</code>, <code>:last</code>, and <code>:nmissing</code>. The default statistics used are <code>:mean</code>, <code>:min</code>, <code>:median</code>, <code>:max</code>, <code>:nunique</code>, <code>:nmissing</code>, and <code>:eltype</code>.</li><li><code>:all</code> as the only <code>Symbol</code> argument to return all statistics.</li><li>A <code>name =&gt; function</code> pair where <code>name</code> is a <code>Symbol</code>. This will create a column of summary statistics with the provided name.</li></ul></li></ul><p><strong>Result</strong></p><ul><li>A <code>DataFrame</code> where each row represents a variable and each column a summary statistic.</li></ul><p><strong>Details</strong></p><p>For <code>Real</code> columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from <code>Real</code>, <code>describe</code> will attempt to calculate all statistics, using <code>nothing</code> as a fall-back in the case of an error.</p><p>When <code>stats</code> contains <code>:nunique</code>, <code>describe</code> will report the number of unique values in a column. If a column&#39;s base type derives from <code>Real</code>, <code>:nunique</code> will return <code>nothing</code>s.</p><p>Missing values are filtered in the calculation of all statistics, however the column <code>:nmissing</code> will report the number of missing values of that variable. If the column does not allow missing values, <code>nothing</code> is returned. Consequently, <code>nmissing = 0</code> indicates that the column allows missing values, but does not currently contain any.</p><p>If custom functions are provided, they are called repeatedly with the vector corresponding to each column as the only argument. For columns allowing for missing values, the vector is wrapped in a call to <a href="lib/@ref"><code>skipmissing</code></a>: custom functions must therefore support such objects (and not only vectors), and cannot access missing values.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
describe([io,] df)
describe([io,] df, :all)
describe([io,] df, :min, :max)
describe([io,] df, :min, :sum =&gt; sum)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L305-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Missings.disallowmissing" href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">disallowmissing(df::AbstractDataFrame,
                cols::Union{ColumnIndex, AbstractVector, Regex, Not, Between, All, Colon}=:)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=Union{Int,Missing}[1,2])
2×1 DataFrame
│ Row │ a      │
│     │ Int64⍰ │
├─────┼────────┤
│ 1   │ 1      │
│ 2   │ 2      │

julia&gt; disallowmissing(df)
2×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L1272-L1300">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.disallowmissing!" href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">disallowmissing!(df::DataFrame, cols::Colon=:)
disallowmissing!(df::DataFrame, cols::Union{Integer, Symbol})
disallowmissing!(df::DataFrame, cols::Union{AbstractVector, Regex, Not, Between, All})</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L924-L933">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.dropmissing" href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dropmissing(df::AbstractDataFrame, cols::Colon=:; disallowmissing::Bool=true)
dropmissing(df::AbstractDataFrame, cols::Union{AbstractVector, Regex, Not, Between, All};
            disallowmissing::Bool=true)
dropmissing(df::AbstractDataFrame, cols::Union{Integer, Symbol};
            disallowmissing::Bool=true)</code></pre><p>Return a copy of data frame <code>df</code> excluding rows with missing values. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>If <code>disallowmissing</code> is <code>true</code> (the default) then columns specified in <code>cols</code> will be converted so as not to allow for missing values using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>See also: <a href="#DataFrames.completecases"><code>completecases</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; dropmissing(df)
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │

julia&gt; dropmissing(df, disallowmissing=false)
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │

julia&gt; dropmissing(df, :x)
3×3 DataFrame
│ Row │ i     │ x     │ y       │
│     │ Int64 │ Int64 │ String⍰ │
├─────┼───────┼───────┼─────────┤
│ 1   │ 2     │ 4     │ missing │
│ 2   │ 4     │ 2     │ d       │
│ 3   │ 5     │ 1     │ e       │

julia&gt; dropmissing(df, [:x, :y])
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L585-L650">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.dropmissing!" href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dropmissing!(df::AbstractDataFrame, cols::Colon=:; disallowmissing::Bool=true)
dropmissing!(df::AbstractDataFrame, cols::Union{AbstractVector, Regex, Not, Between, All};
             disallowmissing::Bool=true)
dropmissing!(df::AbstractDataFrame, cols::Union{Integer, Symbol};
             disallowmissing::Bool=true)</code></pre><p>Remove rows with missing values from data frame <code>df</code> and return it. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>If <code>disallowmissing</code> is <code>true</code> (the default) then the <code>cols</code> columns will get converted using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.completecases"><code>completecases</code></a>.</p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; dropmissing!(copy(df))
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │

julia&gt; dropmissing!(copy(df), disallowmissing=false)
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │

julia&gt; dropmissing!(copy(df), :x)
3×3 DataFrame
│ Row │ i     │ x     │ y       │
│     │ Int64 │ Int64 │ String⍰ │
├─────┼───────┼───────┼─────────┤
│ 1   │ 2     │ 4     │ missing │
│ 2   │ 4     │ 2     │ d       │
│ 3   │ 5     │ 1     │ e       │

julia&gt; dropmissing!(df3, [:x, :y])
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L659-L722">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.eachrow" href="#DataFrames.eachrow"><code>DataFrames.eachrow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eachrow(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameRows</code> that iterates a data frame row by row, with each row represented as a <code>DataFrameRow</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; eachrow(df)
4-element DataFrameRows:
 DataFrameRow (row 1)
x  1
y  11
 DataFrameRow (row 2)
x  2
y  12
 DataFrameRow (row 3)
x  3
y  13
 DataFrameRow (row 4)
x  4
y  14

julia&gt; copy.(eachrow(df))
4-element Array{NamedTuple{(:x, :y),Tuple{Int64,Int64}},1}:
 (x = 1, y = 11)
 (x = 2, y = 12)
 (x = 3, y = 13)
 (x = 4, y = 14)

julia&gt; eachrow(view(df, [4,3], [2,1]))
2-element DataFrameRows:
 DataFrameRow (row 4)
y  14
x  4
 DataFrameRow (row 3)
y  13
x  3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/iteration.jl#L23-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.eachcol" href="#DataFrames.eachcol"><code>DataFrames.eachcol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eachcol(df::AbstractDataFrame, names::Bool=false)</code></pre><p>Return a <code>DataFrameColumns</code> that iterates an <code>AbstractDataFrame</code> column by column. If <code>names</code> is equal to <code>false</code> (the default) iteration returns column vectors. If <code>names</code> is equal to <code>true</code> pairs consisting of column name and column vector are yielded.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; collect(eachcol(df))
2-element Array{AbstractArray{T,1} where T,1}:
 [1, 2, 3, 4]
 [11, 12, 13, 14]

julia&gt; map(eachcol(df)) do col
           maximum(col) - minimum(col)
       end
2-element Array{Int64,1}:
 3
 3

julia&gt; sum.(eachcol(df))
2-element Array{Int64,1}:
 10
 50

julia&gt; collect(eachcol(df, true))
2-element Array{Pair{Symbol,AbstractArray{T,1} where T},1}:
 :x =&gt; [1, 2, 3, 4]
 :y =&gt; [11, 12, 13, 14]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/iteration.jl#L107-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.eltypes" href="#DataFrames.eltypes"><code>DataFrames.eltypes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return element types of columns</p><pre><code class="language-julia">eltypes(df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li></ul><p><strong>Result</strong></p><ul><li><code>::Vector{Type}</code> : the element type of each column</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
eltypes(df)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L174-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">filter(function, df::AbstractDataFrame)</code></pre><p>Return a copy of data frame <code>df</code> containing only rows for which <code>function</code> returns <code>true</code>. The function is passed a <code>DataFrameRow</code> as its only argument.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter(row -&gt; row[:x] &gt; 1, df)
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L731-L757">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter!" href="#Base.filter!"><code>Base.filter!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">filter!(function, df::AbstractDataFrame)</code></pre><p>Remove rows from data frame <code>df</code> for which <code>function</code> returns <code>false</code>. The function is passed a <code>DataFrameRow</code> as its only argument.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter!(row -&gt; row[:x] &gt; 1, df);

julia&gt; df
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L760-L788">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.hcat" href="#Base.hcat"><code>Base.hcat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hcat(df::AbstractDataFrame...;
     makeunique::Bool=false, copycols::Bool=true)
hcat(df::AbstractDataFrame..., vs::AbstractVector;
     makeunique::Bool=false, copycols::Bool=true)
hcat(vs::AbstractVector, df::AbstractDataFrame;
     makeunique::Bool=false, copycols::Bool=true)</code></pre><p>Horizontally concatenate <code>AbstractDataFrames</code> and optionally <code>AbstractVector</code>s.</p><p>If <code>AbstractVector</code> is passed then a column name for it is automatically generated as <code>:x1</code> by default.</p><p>If <code>makeunique=false</code> (the default) column names of passed objects must be unique. If <code>makeunique=true</code> then duplicate column names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p><p>If <code>copycols=true</code> (the default) then the <code>DataFrame</code> returned by <code>hcat</code> will contain copied columns from the source data frames. If <code>copycols=false</code> then it will contain columns as they are stored in the source (without copying). This option should be used with caution as mutating either the columns in sources or in the returned <code>DataFrame</code> might lead to the corruption of the other object.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia [DataFrame(A=1:3) DataFrame(B=1:3)]
3×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │

julia&gt; df1 = DataFrame(A=1:3, B=1:3);

julia&gt; df2 = DataFrame(A=4:6, B=4:6);

julia&gt; df3 = hcat(df1, df2, makeunique=true)
3×4 DataFrame
│ Row │ A     │ B     │ A_1   │ B_1   │
│     │ Int64 │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┼───────┤
│ 1   │ 1     │ 1     │ 4     │ 4     │
│ 2   │ 2     │ 2     │ 5     │ 5     │
│ 3   │ 3     │ 3     │ 6     │ 6     │

julia&gt; df3.A === df1.A
true

julia&gt; df3 = hcat(df1, df2, makeunique=true, copycols=false);

julia&gt; df3.A === df1.A
true
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L920-L977">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.insertcols!" href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Insert a column into a data frame in place.</p><pre><code class="language-julia">insertcols!(df::DataFrame, ind::Int; name=col,
            makeunique::Bool=false)
insertcols!(df::DataFrame, ind::Int, (:name =&gt; col)::Pair{Symbol,&lt;:AbstractVector};
            makeunique::Bool=false)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the DataFrame to which we want to add a column</p></li><li><p><code>ind</code> : a position at which we want to insert a column</p></li><li><p><code>name</code> : the name of the new column</p></li><li><p><code>col</code> : an <code>AbstractVector</code> giving the contents of the new column</p></li><li><p><code>makeunique</code> : Defines what to do if <code>name</code> already exists in <code>df</code>; if it is <code>false</code> an error will be thrown; if it is <code>true</code> a new unique name will be generated by adding a suffix</p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : a <code>DataFrame</code> with added column.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3)
3×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │

julia&gt; insertcols!(d, 1, b=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
3×2 DataFrame
│ Row │ b    │ a     │
│     │ Char │ Int64 │
├─────┼──────┼───────┤
│ 1   │ &#39;a&#39;  │ 1     │
│ 2   │ &#39;b&#39;  │ 2     │
│ 3   │ &#39;c&#39;  │ 3     │

julia&gt; insertcols!(d, 1, :c =&gt; [2, 3, 4])
3×3 DataFrame
│ Row │ c     │ b    │ a     │
│     │ Int64 │ Char │ Int64 │
├─────┼───────┼──────┼───────┤
│ 1   │ 2     │ &#39;a&#39;  │ 1     │
│ 2   │ 3     │ &#39;b&#39;  │ 2     │
│ 3   │ 4     │ &#39;c&#39;  │ 3     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L554-L614">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.mapcols" href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mapcols(f::Union{Function,Type}, df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrame</code> where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars.</p><p>Note that <code>mapcols</code> guarantees not to reuse the columns from <code>df</code> in the returned <code>DataFrame</code>. If <code>f</code> returns its argument then it gets copied before being stored.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; mapcols(x -&gt; x.^2, df)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 121   │
│ 2   │ 4     │ 144   │
│ 3   │ 9     │ 169   │
│ 4   │ 16    │ 196   │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/iteration.jl#L177-L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.names!" href="#DataFrames.names!"><code>DataFrames.names!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Set column names</p><pre><code class="language-julia">names!(df::AbstractDataFrame, vals)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>vals</code> : column names, normally a Vector{Symbol} the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
names!(df, [:a, :b, :c])
names!(df, [:a, :b, :a])  # throws ArgumentError
names!(df, [:a, :b, :a], makeunique=true)  # renames second :a to :a_1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L79-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.nonunique" href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Indexes of duplicate rows (a row that is a duplicate of a prior row)</p><pre><code class="language-julia">nonunique(df::AbstractDataFrame)
nonunique(df::AbstractDataFrame, cols)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> : a column indicator (Symbol, Int, Vector{Symbol}, etc.) specifying the column(s) to compare</li></ul><p><strong>Result</strong></p><ul><li><code>::Vector{Bool}</code> : indicates whether the row is a duplicate of some prior row</li></ul><p>See also <a href="lib/@ref"><code>unique</code></a> and <a href="#Base.unique!"><code>unique!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
df = vcat(df, df)
nonunique(df)
nonunique(df, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L819-L848">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.nrow" href="#DataFrames.nrow"><code>DataFrames.nrow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nrow(df::AbstractDataFrame)
ncol(df::AbstractDataFrame)</code></pre><p>Return the number of rows or columns in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also <a href="lib/@ref"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; size(df)
(10, 3)

julia&gt; nrow(df)
10

julia&gt; ncol(df)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L1245-L1269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.ncol" href="#DataFrames.ncol"><code>DataFrames.ncol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nrow(df::AbstractDataFrame)
ncol(df::AbstractDataFrame)</code></pre><p>Return the number of rows or columns in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also <a href="lib/lib/@ref"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; size(df)
(10, 3)

julia&gt; nrow(df)
10

julia&gt; ncol(df)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L1245-L1269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.rename!" href="#DataFrames.rename!"><code>DataFrames.rename!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Rename columns</p><pre><code class="language-julia">rename!(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename!(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename!(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename!(f::Function, df::AbstractDataFrame)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename(f::Function, df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>d</code> : an Associative type or an AbstractArray of pairs that maps the original names to new names</li><li><code>f</code> : a function which for each column takes the old name (a Symbol) and returns the new name (a Symbol)</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p>New names are processed sequentially. A new name must not already exist in the <code>DataFrame</code> at the moment an attempt to rename a column is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
rename(df, :i =&gt; :A, :x =&gt; :X)
rename(df, [:i =&gt; :A, :x =&gt; :X])
rename(df, Dict(:i =&gt; :A, :x =&gt; :X))
rename(x -&gt; Symbol(uppercase(string(x))), df)
rename(df) do x
    Symbol(uppercase(string(x)))
end
rename!(df, Dict(:i =&gt;: A, :x =&gt; :X))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L128-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.rename" href="#DataFrames.rename"><code>DataFrames.rename</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Rename columns</p><pre><code class="language-julia">rename!(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename!(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename!(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename!(f::Function, df::AbstractDataFrame)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename(f::Function, df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>d</code> : an Associative type or an AbstractArray of pairs that maps the original names to new names</li><li><code>f</code> : a function which for each column takes the old name (a Symbol) and returns the new name (a Symbol)</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p>New names are processed sequentially. A new name must not already exist in the <code>DataFrame</code> at the moment an attempt to rename a column is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
rename(df, :i =&gt; :A, :x =&gt; :X)
rename(df, [:i =&gt; :A, :x =&gt; :X])
rename(df, Dict(:i =&gt; :A, :x =&gt; :X))
rename(x -&gt; Symbol(uppercase(string(x))), df)
rename(df) do x
    Symbol(uppercase(string(x)))
end
rename!(df, Dict(:i =&gt;: A, :x =&gt; :X))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L128-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repeat" href="#Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)</code></pre><p>Construct a data frame by repeating rows in <code>df</code>. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat(df, inner = 2, outer = 3)
12×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 1     │ 3     │
│ 3   │ 2     │ 4     │
│ 4   │ 2     │ 4     │
│ 5   │ 1     │ 3     │
│ 6   │ 1     │ 3     │
│ 7   │ 2     │ 4     │
│ 8   │ 2     │ 4     │
│ 9   │ 1     │ 3     │
│ 10  │ 1     │ 3     │
│ 11  │ 2     │ 4     │
│ 12  │ 2     │ 4     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L1151-L1186">source</a><div><div><pre><code class="language-none">repeat(df::AbstractDataFrame, count::Integer)</code></pre><p>Construct a data frame by repeating each row in <code>df</code> the number of times specified by <code>count</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat(df, 2)
4×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │
│ 3   │ 1     │ 3     │
│ 4   │ 2     │ 4     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L1190-L1216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.select" href="#DataFrames.select"><code>DataFrames.select</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">select(df::AbstractDataFrame, inds, copycols::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> specified by <code>inds</code> and return it.</p><p>Argument <code>inds</code> can be any index that is allowed for column indexing.</p><p>If <code>df</code> is a <code>DataFrame</code> return a new <code>DataFrame</code> that contains columns from <code>df</code> specified by <code>inds</code>. If <code>copycols=true</code> (the default), then returned <code>DataFrame</code> holds copies of column vectors in <code>df</code>. If <code>copycols=false</code>, then returned <code>DataFrame</code> shares column vectors with <code>df</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> then a <code>SubDataFrame</code> is returned if <code>copycols=false</code> and a <code>DataFrame</code> with freshly allocated columns otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; select(d, :b)
3×1 DataFrame
│ Row │ b     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 4     │
│ 2   │ 5     │
│ 3   │ 6     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L779-L818">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.select!" href="#DataFrames.select!"><code>DataFrames.select!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">select!(df::DataFrame, inds)</code></pre><p>Mutate <code>df</code> in place to retain only columns specified by <code>inds</code> and return it.</p><p>Argument <code>inds</code> can be any index that is allowed for column indexing of a <code>DataFrame</code> provided that the columns requested to be removed are unique.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; select!(d, 2)
3×1 DataFrame
│ Row │ b     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 4     │
│ 2   │ 5     │
│ 3   │ 6     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L720-L750">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show" href="#Base.show"><code>Base.show</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">show([io::IO,] df::AbstractDataFrame;
     allrows::Bool = !get(io, :limit, false),
     allcols::Bool = !get(io, :limit, false),
     allgroups::Bool = !get(io, :limit, false),
     splitcols::Bool = get(io, :limit, false),
     rowlabel::Symbol = :Row,
     summary::Bool = true)</code></pre><p>Render a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.</p><p>If <code>io</code> is omitted, the result is printed to <code>stdout</code>, and <code>allrows</code>, <code>allcols</code> and <code>allgroups</code> default to <code>false</code> while <code>splitcols</code> defaults to <code>true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li><li><code>allrows::Bool</code>: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allcols::Bool</code>: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allgroups::Bool</code>: Whether to print all groups rather than the first and last, when <code>df</code> is a <code>GroupedDataFrame</code>. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>splitcols::Bool</code>: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block. Only applies if <code>allcols</code> is <code>true</code>. By default this is the case only if <code>io</code> has the <code>IOContext</code> property <code>limit</code> set.</li><li><code>rowlabel::Symbol = :Row</code>: The label to use for the column containing row numbers.</li><li><code>summary::Bool = true</code>: Whether to print a brief string summary of the data frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; show(df, allcols=true)
3×2 DataFrame
│ Row │ A     │ B      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ x      │
│ 2   │ 2     │ y      │
│ 3   │ 3     │ z      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/show.jl#L552-L602">source</a><div><div><pre><code class="language-none">show(io::IO, mime::MIME, df::AbstractDataFrame)</code></pre><p>Render a data frame to an I/O stream in MIME type <code>mime</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>mime::MIME</code>: supported MIME types are: <code>&quot;text/plain&quot;</code>, <code>&quot;text/html&quot;</code>, <code>&quot;text/latex&quot;</code>, <code>&quot;text/csv&quot;</code>, <code>&quot;text/tab-separated-values&quot;</code></li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li></ul><p>Additionally selected MIME types support passing the following keyword arguments:</p><ul><li>MIME type <code>&quot;text/plain&quot;</code> accepts all listed keyword arguments and therir behavior is identical as for <code>show(::IO, ::AbstractDataFrame)</code></li><li>MIME type <code>&quot;text/html&quot;</code> accepts <code>summary</code> keyword argument which allows to choose whether to print a brief string summary of the data frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; show(stdout, MIME(&quot;text/latex&quot;), DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
\begin{tabular}{r|cc}
        &amp; A &amp; B\\
        \hline
        &amp; Int64 &amp; String\\
        \hline
        1 &amp; 1 &amp; x \\
        2 &amp; 2 &amp; y \\
        3 &amp; 3 &amp; z \\
\end{tabular}
14

julia&gt; show(stdout, MIME(&quot;text/csv&quot;), DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
&quot;A&quot;,&quot;B&quot;
1,&quot;x&quot;
2,&quot;y&quot;
3,&quot;z&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/io.jl#L1-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort" href="#Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sort(df::AbstractDataFrame, cols;
     alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
     rev::Bool=false, order::Ordering=Forward)</code></pre><p>Return a copy of data frame <code>df</code> sorted by column(s) <code>cols</code>. <code>cols</code> can be either a <code>Symbol</code> or <code>Integer</code> column index, or a tuple or vector of such indices.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See <a href="#Base.sort!"><code>sort!</code></a> for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, (:x, :y))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, (:x, :y), rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, (:x, order(:y, rev=true)))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/sort.jl#L305-L374">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort!" href="#Base.sort!"><code>Base.sort!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sort!(df::AbstractDataFrame, cols;
      alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
      rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort data frame <code>df</code> by column(s) <code>cols</code>. <code>cols</code> can be either a <code>Symbol</code> or <code>Integer</code> column index, or a tuple or vector of such indices.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See other methods for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, (:x, :y))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, (:x, :y), rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, (:x, order(:y, rev=true)))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/sort.jl#L2-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unique!" href="#Base.unique!"><code>Base.unique!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Delete duplicate rows</p><pre><code class="language-julia">unique(df::AbstractDataFrame)
unique(df::AbstractDataFrame, cols)
unique!(df::AbstractDataFrame)
unique!(df::AbstractDataFrame, cols)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)</li></ul><p>specifying the column(s) to compare.</p><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated version of <code>df</code> with unique rows.</li></ul><p>When <code>cols</code> is specified, the return DataFrame contains complete rows, retaining in each case the first instance for which <code>df[cols]</code> is unique.</p><p>See also <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
df = vcat(df, df)
unique(df)   # doesn&#39;t modify df
unique(df, 1)
unique!(df)  # modifies df</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L876-L910">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.permutecols!" href="#DataFrames.permutecols!"><code>DataFrames.permutecols!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">permutecols!(df::DataFrame, p::AbstractVector)</code></pre><p>Permute the columns of <code>df</code> in-place, according to permutation <code>p</code>. Elements of <code>p</code> may be either column indices (<code>Int</code>) or names (<code>Symbol</code>), but cannot be a combination of both. All columns must be listed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(a=1:5, b=2:6, c=3:7)
5×3 DataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │
│ 2   │ 2     │ 3     │ 4     │
│ 3   │ 3     │ 4     │ 5     │
│ 4   │ 4     │ 5     │ 6     │
│ 5   │ 5     │ 6     │ 7     │

julia&gt; permutecols!(df, [2, 1, 3]);

julia&gt; df
5×3 DataFrame
│ Row │ b     │ a     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 1     │ 3     │
│ 2   │ 3     │ 2     │ 4     │
│ 3   │ 4     │ 3     │ 5     │
│ 4   │ 5     │ 4     │ 6     │
│ 5   │ 6     │ 5     │ 7     │

julia&gt; permutecols!(df, [:c, :a, :b]);

julia&gt; df
5×3 DataFrame
│ Row │ c     │ a     │ b     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 1     │ 2     │
│ 2   │ 4     │ 2     │ 3     │
│ 3   │ 5     │ 3     │ 4     │
│ 4   │ 6     │ 4     │ 5     │
│ 5   │ 7     │ 5     │ 6     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L1307-L1354">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.vcat" href="#Base.vcat"><code>Base.vcat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">vcat(dfs::AbstractDataFrame...; cols::Union{Symbol, AbstractVector{Symbol}}=:equal)</code></pre><p>Vertically concatenate <code>AbstractDataFrame</code>s.</p><p>The <code>cols</code> keyword argument determines the columns of the returned data frame:</p><ul><li><code>:equal</code> (the default): require all data frames to have the same column names. If they appear in different orders, the order of the first provided data frame is used.</li><li><code>:intersect</code>: only the columns present in <em>all</em> provided data frames are kept. If the intersection is empty, an empty data frame is returned.</li><li><code>:union</code>: columns present in <em>at least one</em> of the provided data frames are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li><li>A vector of <code>Symbol</code>s: only listed columns are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li></ul><p>The order of columns is determined by the order they appear in the included data frames, searching through the header of the first data frame, then the second, etc.</p><p>The element types of columns are determined using <code>promote_type</code>, as with <code>vcat</code> for <code>AbstractVector</code>s.</p><p><code>vcat</code> ignores empty data frames, making it possible to initialize an empty data frame at the beginning of a loop and <code>vcat</code> onto it.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3);

julia&gt; df2 = DataFrame(A=4:6, B=4:6);

julia&gt; df3 = DataFrame(A=7:9, C=7:9);

julia&gt; d4 = DataFrame();

julia&gt; vcat(df1, df2)
6×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 4     │ 4     │
│ 5   │ 5     │ 5     │
│ 6   │ 6     │ 6     │

julia&gt; vcat(df1, df3, cols=:union)
6×3 DataFrame
│ Row │ A     │ B       │ C       │
│     │ Int64 │ Int64⍰  │ Int64⍰  │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ 1       │ missing │
│ 2   │ 2     │ 2       │ missing │
│ 3   │ 3     │ 3       │ missing │
│ 4   │ 7     │ missing │ 7       │
│ 5   │ 8     │ missing │ 8       │
│ 6   │ 9     │ missing │ 9       │

julia&gt; vcat(df1, df3, cols=:intersect)
6×1 DataFrame
│ Row │ A     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │
│ 4   │ 7     │
│ 5   │ 8     │
│ 6   │ 9     │

julia&gt; vcat(d4, df1)
3×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/abstractdataframe/abstractdataframe.jl#L998-L1080">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">append!(df1::DataFrame, df2::AbstractDataFrame)</code></pre><p>Add the rows of <code>df2</code> to the end of <code>df1</code>.</p><p>Column names must be equal (including order), with the following exceptions:</p><ul><li>If <code>df1</code> has no columns then copies of columns from <code>df2</code> are added to it.</li><li>If <code>df2</code> has no columns then calling <code>append!</code> leaves <code>df1</code> unchanged.</li></ul><p>Values corresponding to new rows are appended in-place to the column vectors of <code>df1</code>. Column types are therefore preserved, and new values are converted if necessary. An error is thrown if conversion fails: this is the case in particular if a column in <code>df2</code> contains <code>missing</code> values but the corresponding column in <code>df1</code> does not accept them.</p><p>Please note that <code>append!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Use <a href="#Base.vcat"><code>vcat</code></a> instead of <code>append!</code> when more flexibility is needed. Since <code>vcat</code> does not operate in place, it is able to use promotion to find an appropriate element type to hold values from both data frames. It also accepts columns in different orders between <code>df1</code> and <code>df2</code>.</p><p>Use <a href="#Base.push!"><code>push!</code></a> to add individual rows to a data frame.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3);

julia&gt; df2 = DataFrame(A=4.0:6.0, B=4:6);

julia&gt; append!(df1, df2);

julia&gt; df1
6×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 4     │ 4     │
│ 5   │ 5     │ 5     │
│ 6   │ 6     │ 6     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L1068-L1115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">push!(df::DataFrame, row)
push!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict};
      columns::Symbol=:intersect)</code></pre><p>Add in-place one row at the end of <code>df</code> taking the values from <code>row</code>.</p><p>Column types of <code>df</code> are preserved, and new values are converted if necessary. An error is thrown if conversion fails.</p><p>If <code>row</code> is neither a <code>DataFrameRow</code>, <code>NamedTuple</code> nor <code>AbstractDict</code> then it is assumed to be an iterable and columns are matched by order of appearance. In this case <code>row</code> must contain the same number of elements as the number of columns in <code>df</code>.</p><p>If <code>row</code> is a <code>DataFrameRow</code>, <code>NamedTuple</code> or <code>AbstractDict</code> then values in <code>row</code> are matched to columns in <code>df</code> based on names (order is ignored). <code>row</code> may contain more columns than <code>df</code> if <code>columns=:intersect</code> (this is currently the default, but will change in the future), but all column names that are present in <code>df</code> must be present in <code>row</code>. Otherwise if <code>columns=:equal</code> then <code>row</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</p><p>As a special case, if <code>df</code> has no columns and <code>row</code> is a <code>NamedTuple</code> or <code>DataFrameRow</code>, columns are created for all values in <code>row</code>, using their names and order.</p><p>Please note that <code>push!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │

julia&gt; push!(df, (true, false))
4×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 1     │ 0     │

julia&gt; push!(df, df[1, :])
5×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 1     │ 0     │
│ 5   │ 1     │ 1     │

julia&gt; push!(df, (C=&quot;something&quot;, A=true, B=false), columns=:intersect)
4×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 1     │ 0     │
│ 5   │ 1     │ 1     │
│ 6   │ 1     │ 0     │

julia&gt; push!(df, Dict(:A=&gt;1.0, :B=&gt;2.0))
5×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 1     │ 0     │
│ 5   │ 1     │ 1     │
│ 6   │ 1     │ 0     │
│ 7   │ 1     │ 2     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a9b83b5f7d3cd31cbfddb77a3b771179f2d44628/src/dataframe/dataframe.jl#L1193-L1278">source</a></section><footer><hr/><a class="previous" href="../types/"><span class="direction">Previous</span><span class="title">Types</span></a><a class="next" href="../indexing/"><span class="direction">Next</span><span class="title">Indexing</span></a></footer></article></body></html>
