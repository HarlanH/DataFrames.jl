<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Internals · DataFrames.jl</title><link href="https://juliadata.github.io/DataFrames.jl/stable/lib/internals/index.html" rel="canonical"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../../"><img alt="DataFrames.jl logo" class="logo" src="../../assets/logo.png"/></a><h1>DataFrames.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/joins/">Joins</a></li><li><a class="toctext" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="toctext" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="toctext" href="../../man/sorting/">Sorting</a></li><li><a class="toctext" href="../../man/categorical/">Categorical Data</a></li><li><a class="toctext" href="../../man/missing/">Missing Data</a></li><li><a class="toctext" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../types/">Types</a></li><li><a class="toctext" href="../functions/">Functions</a></li><li><a class="toctext" href="../indexing/">Indexing</a></li><li class="current"><a class="toctext" href="">Internals</a><ul class="internal"></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href="">Internals</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/DataFrames.jl/blob/master/docs/src/lib/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Internals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Internals-1" id="Internals-1">Internals</a></h1><div class="admonition warning"><div class="admonition-title">Internal API</div><div class="admonition-text"><p>The functions, methods and types listed on this page are internal to DataFrames and are <strong>not considered to be part of the public API</strong>.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.compacttype" id="DataFrames.compacttype"><code>DataFrames.compacttype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return compact string representation of type T</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/bdc83e6a86b88bdd8e611f585ddc095e8c2236af/src/abstractdataframe/show.jl#L67" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.gennames" id="DataFrames.gennames"><code>DataFrames.gennames</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gennames(n::Integer)</code></pre><p>Generate standardized names for columns of a DataFrame. The first name will be <code>:x1</code>, the second <code>:x2</code>, etc.</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/bdc83e6a86b88bdd8e611f585ddc095e8c2236af/src/other/utils.jl#L60-L65" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.getchunkbounds" id="DataFrames.getchunkbounds"><code>DataFrames.getchunkbounds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getchunkbounds(maxwidths::Vector{Int},
               splitcols::Bool,
               availablewidth::Int)</code></pre><p>When rendering an <code>AbstractDataFrame</code> to a REPL window in chunks, each of which will fit within the width of the REPL window, this function will return the indices of the columns that should be included in each chunk.</p><p>NOTE: The resulting bounds should be interpreted as follows: the i-th chunk bound is the index MINUS 1 of the first column in the i-th chunk. The (i + 1)-th chunk bound is the EXACT index of the last column in the i-th chunk. For example, the bounds [0, 3, 5] imply that the first chunk contains columns 1-3 and the second chunk contains columns 4-5.</p><p><strong>Arguments</strong></p><ul><li><code>maxwidths::Vector{Int}</code>: The maximum width needed to render each column of an AbstractDataFrame.</li><li><code>splitcols::Bool</code>: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block.</li><li><code>availablewidth::Int</code>: The available width in the REPL.</li></ul><p>```</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/bdc83e6a86b88bdd8e611f585ddc095e8c2236af/src/abstractdataframe/show.jl#L227-L250" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.getmaxwidths" id="DataFrames.getmaxwidths"><code>DataFrames.getmaxwidths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">DataFrames.getmaxwidths(df::AbstractDataFrame,
                        io::IO,
                        rowindices1::AbstractVector{Int},
                        rowindices2::AbstractVector{Int},
                        rowlabel::Symbol,
                        rowid::Union{Integer, Nothing},
                        show_eltype::Bool,
                        buffer::IOBuffer)</code></pre><p>Calculate, for each column of an AbstractDataFrame, the maximum string width used to render the name of that column, its type, and the longest entry in that column – among the rows of the data frame will be rendered to IO. The widths for all columns are returned as a vector.</p><p>Return a <code>Vector{Int}</code> giving the maximum string widths required to render each column, including that column's name and type.</p><p>NOTE: The last entry of the result vector is the string width of the implicit row ID column contained in every <code>AbstractDataFrame</code>.</p><p><strong>Arguments</strong></p><ul><li><code>df::AbstractDataFrame</code>: The data frame whose columns will be printed.</li><li><code>io::IO</code>: The <code>IO</code> to which <code>df</code> is to be printed</li><li>`rowindices1::AbstractVector{Int}: A set of indices of the first chunk of the AbstractDataFrame that would be rendered to IO.</li><li>`rowindices2::AbstractVector{Int}: A set of indices of the second chunk of the AbstractDataFrame that would be rendered to IO. Can be empty if the AbstractDataFrame would be printed without any ellipses.</li><li><code>rowlabel::AbstractString</code>: The label that will be used when rendered the numeric ID's of each row. Typically, this will be set to "Row".</li><li><code>rowid</code>: Used to handle showing <code>DataFrameRow</code>.</li><li><code>show_eltype</code>: Whether to print the column type  under the column name in the heading.</li><li><code>buffer</code>: buffer passed around to avoid reallocations in <code>ourstrwidth</code></li></ul><p>```</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/bdc83e6a86b88bdd8e611f585ddc095e8c2236af/src/abstractdataframe/show.jl#L119-L157" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.getprintedwidth" id="DataFrames.getprintedwidth"><code>DataFrames.getprintedwidth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">DataFrames.getprintedwidth(maxwidths::Vector{Int})</code></pre><p>Given the maximum widths required to render each column of an <code>AbstractDataFrame</code>, return the total number of characters that would be required to render an entire row to an I/O stream.</p><p>NOTE: This width includes the whitespace and special characters used to pretty print the <code>AbstractDataFrame</code>.</p><p><strong>Arguments</strong></p><ul><li><code>maxwidths::Vector{Int}</code>: The maximum width needed to render each column of an <code>AbstractDataFrame</code>.</li></ul><p>```</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/bdc83e6a86b88bdd8e611f585ddc095e8c2236af/src/abstractdataframe/show.jl#L202-L216" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.ourshow" id="DataFrames.ourshow"><code>DataFrames.ourshow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">DataFrames.ourshow(io::IO, x::Any)</code></pre><p>Render a value to an <code>IO</code> object compactly and omitting type information, by calling 3-argument <code>show</code>, or 2-argument <code>show</code> if the former contains line breaks. Unlike <code>show</code>, render strings without surrounding quote marks.</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/bdc83e6a86b88bdd8e611f585ddc095e8c2236af/src/abstractdataframe/show.jl#L16-L22" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.ourstrwidth" id="DataFrames.ourstrwidth"><code>DataFrames.ourstrwidth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">DataFrames.ourstrwidth(io::IO, x::Any, buffer)</code></pre><p>Determine the number of characters that would be used to print a value.</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/bdc83e6a86b88bdd8e611f585ddc095e8c2236af/src/abstractdataframe/show.jl#L5-L9" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.showrowindices" id="DataFrames.showrowindices"><code>DataFrames.showrowindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">showrowindices(io::IO,
               df::AbstractDataFrame,
               rowindices::AbstractVector{Int},
               maxwidths::Vector{Int},
               leftcol::Int,
               rightcol::Int,
               rowid::Union{Int,Nothing},
               buffer::IOBuffer)</code></pre><p>Render a subset of rows and columns of an <code>AbstractDataFrame</code> to an I/O stream. For chunked printing, this function is used to print a single chunk, starting from the first indicated column and ending with the last indicated column. Assumes that the maximum string widths required for printing have been precomputed.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: An AbstractDataFrame.</li><li><code>rowindices::AbstractVector{Int}</code>: The indices of the subset of rows that will be rendered to <code>io</code>.</li><li><code>maxwidths::Vector{Int}</code>: The pre-computed maximum string width required to render each column.</li><li><code>leftcol::Int</code>: The index of the first column in a chunk to be rendered.</li><li><code>rightcol::Int</code>: The index of the last column in a chunk to be rendered.</li><li><code>rowid</code>: Used to handle showing <code>DataFrameRow</code>.</li><li><code>buffer</code>: buffer passed around to avoid reallocations in <code>ourstrwidth</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:3, B = ["x", "y", "z"]);

julia&gt; DataFrames.showrowindices(stdout, df, 1:2, [1, 1, 5], 1, 2)
│ 1     │ 1 │ x │
│ 2     │ 2 │ y │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/bdc83e6a86b88bdd8e611f585ddc095e8c2236af/src/abstractdataframe/show.jl#L275-L313" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.showrows" id="DataFrames.showrows"><code>DataFrames.showrows</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">showrows(io::IO,
         df::AbstractDataFrame,
         rowindices1::AbstractVector{Int},
         rowindices2::AbstractVector{Int},
         maxwidths::Vector{Int},
         splitcols::Bool,
         allcols::Bool,
         rowlabel::Symbol,
         displaysummary::Bool,
         eltypes::Bool,
         rowid::Union{Integer, Nothing},
         buffer::IOBuffer)</code></pre><p>Render a subset of rows (possibly in chunks) of an <code>AbstractDataFrame</code> to an I/O stream.</p><p>NOTE: The value of <code>maxwidths[end]</code> must be the string width of <code>rowlabel</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: An AbstractDataFrame.</li><li><code>rowindices1::AbstractVector{Int}</code>: The indices of the first subset of rows to be rendered.</li><li><code>rowindices2::AbstractVector{Int}</code>: The indices of the second subset of rows to be rendered. An ellipsis will be printed before rendering this second subset of rows.</li><li><code>maxwidths::Vector{Int}</code>: The pre-computed maximum string width required to render each column.</li><li><code>allcols::Bool = false</code>: Whether to print all columns, rather than a subset that fits the device width.</li><li><code>splitcols::Bool</code>: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block.</li><li><code>rowlabel::Symbol</code>: What label should be printed when rendering the numeric ID's of each row? Defaults to <code>:Row</code>.</li><li><code>displaysummary::Bool</code>: Should a brief string summary of the AbstractDataFrame be rendered to the I/O stream before printing the contents of the renderable rows? Defaults to <code>true</code>.</li><li><code>eltypes::Bool = true</code>: Whether to print the column type  under the column name in the heading. Defaults to <code>true</code>.</li><li><code>rowid::Union{Integer, Nothing} = nothing</code>: Used to handle showing <code>DataFrameRow</code></li><li><code>buffer::IOBuffer</code>: buffer passed around to avoid reallocations in <code>ourstrwidth</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:3, B = ["x", "y", "z"]);

julia&gt; DataFrames.showrows(stdout, df, 1:2, 3:3, [5, 6, 3], false, true, :Row, true)
3×2 DataFrame
│ Row │ A     │ B      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ x      │
│ 2   │ 2     │ y      │
⋮
│ 3   │ 3     │ z      │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/bdc83e6a86b88bdd8e611f585ddc095e8c2236af/src/abstractdataframe/show.jl#L369-L430" target="_blank">source</a></section><footer><hr/><a class="previous" href="../indexing/"><span class="direction">Previous</span><span class="title">Indexing</span></a></footer></article></body></HTML>