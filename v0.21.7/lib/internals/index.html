<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Internals · DataFrames.jl</title><link href="https://juliadata.github.io/DataFrames.jl/stable/lib/internals/index.html" rel="canonical"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img alt="DataFrames.jl logo" src="../../assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">DataFrames.jl</span></div><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/joins/">Joins</a></li><li><a class="tocitem" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../../man/sorting/">Sorting</a></li><li><a class="tocitem" href="../../man/categorical/">Categorical Data</a></li><li><a class="tocitem" href="../../man/missing/">Missing Data</a></li><li><a class="tocitem" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../indexing/">Indexing</a></li><li class="is-active"><a class="tocitem" href="">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="">Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFrames.jl/blob/master/docs/src/lib/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Internal API</header><div class="admonition-body"><p>The functions, methods and types listed on this page are internal to DataFrames and are <strong>not considered to be part of the public API</strong>.</p></div></div><article class="docstring"><header><a class="docstring-binding" href="#DataFrames.compacttype" id="DataFrames.compacttype"><code>DataFrames.compacttype</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return compact string representation of type T</p></div><a class="docs-sourcelink" href="https://github.com/JuliaData/DataFrames.jl/blob/71843b1226f6c8d06121c4e763bf29d8a3da107b/src/abstractdataframe/show.jl#L67" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DataFrames.gennames" id="DataFrames.gennames"><code>DataFrames.gennames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gennames(n::Integer)</code></pre><p>Generate standardized names for columns of a DataFrame. The first name will be <code>:x1</code>, the second <code>:x2</code>, etc.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaData/DataFrames.jl/blob/71843b1226f6c8d06121c4e763bf29d8a3da107b/src/other/utils.jl#L60-L65" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DataFrames.getchunkbounds" id="DataFrames.getchunkbounds"><code>DataFrames.getchunkbounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getchunkbounds(maxwidths::Vector{Int},
               splitcols::Bool,
               availablewidth::Int)</code></pre><p>When rendering an <code>AbstractDataFrame</code> to a REPL window in chunks, each of which will fit within the width of the REPL window, this function will return the indices of the columns that should be included in each chunk.</p><p>NOTE: The resulting bounds should be interpreted as follows: the i-th chunk bound is the index MINUS 1 of the first column in the i-th chunk. The (i + 1)-th chunk bound is the EXACT index of the last column in the i-th chunk. For example, the bounds [0, 3, 5] imply that the first chunk contains columns 1-3 and the second chunk contains columns 4-5.</p><p><strong>Arguments</strong></p><ul><li><code>maxwidths::Vector{Int}</code>: The maximum width needed to render each column of an AbstractDataFrame.</li><li><code>splitcols::Bool</code>: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block.</li><li><code>availablewidth::Int</code>: The available width in the REPL.</li></ul><p>```</p></div><a class="docs-sourcelink" href="https://github.com/JuliaData/DataFrames.jl/blob/71843b1226f6c8d06121c4e763bf29d8a3da107b/src/abstractdataframe/show.jl#L224-L247" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DataFrames.getmaxwidths" id="DataFrames.getmaxwidths"><code>DataFrames.getmaxwidths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DataFrames.getmaxwidths(df::AbstractDataFrame,
                        io::IO,
                        rowindices1::AbstractVector{Int},
                        rowindices2::AbstractVector{Int},
                        rowlabel::Symbol,
                        rowid::Union{Integer, Nothing},
                        show_eltype::Bool,
                        buffer::IOBuffer)</code></pre><p>Calculate, for each column of an AbstractDataFrame, the maximum string width used to render the name of that column, its type, and the longest entry in that column – among the rows of the data frame will be rendered to IO. The widths for all columns are returned as a vector.</p><p>Return a <code>Vector{Int}</code> giving the maximum string widths required to render each column, including that column's name and type.</p><p>NOTE: The last entry of the result vector is the string width of the implicit row ID column contained in every <code>AbstractDataFrame</code>.</p><p><strong>Arguments</strong></p><ul><li><code>df::AbstractDataFrame</code>: The data frame whose columns will be printed.</li><li><code>io::IO</code>: The <code>IO</code> to which <code>df</code> is to be printed</li><li>`rowindices1::AbstractVector{Int}: A set of indices of the first chunk of the AbstractDataFrame that would be rendered to IO.</li><li>`rowindices2::AbstractVector{Int}: A set of indices of the second chunk of the AbstractDataFrame that would be rendered to IO. Can be empty if the AbstractDataFrame would be printed without any ellipses.</li><li><code>rowlabel::AbstractString</code>: The label that will be used when rendered the numeric ID's of each row. Typically, this will be set to "Row".</li><li><code>rowid</code>: Used to handle showing <code>DataFrameRow</code>.</li><li><code>show_eltype</code>: Whether to print the column type  under the column name in the heading.</li><li><code>buffer</code>: buffer passed around to avoid reallocations in <code>ourstrwidth</code></li></ul><p>```</p></div><a class="docs-sourcelink" href="https://github.com/JuliaData/DataFrames.jl/blob/71843b1226f6c8d06121c4e763bf29d8a3da107b/src/abstractdataframe/show.jl#L116-L154" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DataFrames.getprintedwidth" id="DataFrames.getprintedwidth"><code>DataFrames.getprintedwidth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DataFrames.getprintedwidth(maxwidths::Vector{Int})</code></pre><p>Given the maximum widths required to render each column of an <code>AbstractDataFrame</code>, return the total number of characters that would be required to render an entire row to an I/O stream.</p><p>NOTE: This width includes the whitespace and special characters used to pretty print the <code>AbstractDataFrame</code>.</p><p><strong>Arguments</strong></p><ul><li><code>maxwidths::Vector{Int}</code>: The maximum width needed to render each column of an <code>AbstractDataFrame</code>.</li></ul><p>```</p></div><a class="docs-sourcelink" href="https://github.com/JuliaData/DataFrames.jl/blob/71843b1226f6c8d06121c4e763bf29d8a3da107b/src/abstractdataframe/show.jl#L199-L213" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DataFrames.ourshow" id="DataFrames.ourshow"><code>DataFrames.ourshow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DataFrames.ourshow(io::IO, x::Any)</code></pre><p>Render a value to an <code>IO</code> object compactly and omitting type information, by calling 3-argument <code>show</code>, or 2-argument <code>show</code> if the former contains line breaks. Unlike <code>show</code>, render strings without surrounding quote marks.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaData/DataFrames.jl/blob/71843b1226f6c8d06121c4e763bf29d8a3da107b/src/abstractdataframe/show.jl#L16-L22" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DataFrames.ourstrwidth" id="DataFrames.ourstrwidth"><code>DataFrames.ourstrwidth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DataFrames.ourstrwidth(io::IO, x::Any, buffer)</code></pre><p>Determine the number of characters that would be used to print a value.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaData/DataFrames.jl/blob/71843b1226f6c8d06121c4e763bf29d8a3da107b/src/abstractdataframe/show.jl#L5-L9" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DataFrames.showrowindices" id="DataFrames.showrowindices"><code>DataFrames.showrowindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showrowindices(io::IO,
               df::AbstractDataFrame,
               rowindices::AbstractVector{Int},
               maxwidths::Vector{Int},
               leftcol::Int,
               rightcol::Int,
               rowid::Union{Int,Nothing},
               buffer::IOBuffer)</code></pre><p>Render a subset of rows and columns of an <code>AbstractDataFrame</code> to an I/O stream. For chunked printing, this function is used to print a single chunk, starting from the first indicated column and ending with the last indicated column. Assumes that the maximum string widths required for printing have been precomputed.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: An AbstractDataFrame.</li><li><code>rowindices::AbstractVector{Int}</code>: The indices of the subset of rows that will be rendered to <code>io</code>.</li><li><code>maxwidths::Vector{Int}</code>: The pre-computed maximum string width required to render each column.</li><li><code>leftcol::Int</code>: The index of the first column in a chunk to be rendered.</li><li><code>rightcol::Int</code>: The index of the last column in a chunk to be rendered.</li><li><code>rowid</code>: Used to handle showing <code>DataFrameRow</code>.</li><li><code>buffer</code>: buffer passed around to avoid reallocations in <code>ourstrwidth</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:3, B = ["x", "y", "z"]);

julia&gt; DataFrames.showrowindices(stdout, df, 1:2, [1, 1, 5], 1, 2)
│ 1     │ 1 │ x │
│ 2     │ 2 │ y │</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaData/DataFrames.jl/blob/71843b1226f6c8d06121c4e763bf29d8a3da107b/src/abstractdataframe/show.jl#L272-L310" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DataFrames.showrows" id="DataFrames.showrows"><code>DataFrames.showrows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showrows(io::IO,
         df::AbstractDataFrame,
         rowindices1::AbstractVector{Int},
         rowindices2::AbstractVector{Int},
         maxwidths::Vector{Int},
         splitcols::Bool,
         allcols::Bool,
         rowlabel::Symbol,
         displaysummary::Bool,
         eltypes::Bool,
         rowid::Union{Integer, Nothing},
         buffer::IOBuffer)</code></pre><p>Render a subset of rows (possibly in chunks) of an <code>AbstractDataFrame</code> to an I/O stream.</p><p>NOTE: The value of <code>maxwidths[end]</code> must be the string width of <code>rowlabel</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: An AbstractDataFrame.</li><li><code>rowindices1::AbstractVector{Int}</code>: The indices of the first subset of rows to be rendered.</li><li><code>rowindices2::AbstractVector{Int}</code>: The indices of the second subset of rows to be rendered. An ellipsis will be printed before rendering this second subset of rows.</li><li><code>maxwidths::Vector{Int}</code>: The pre-computed maximum string width required to render each column.</li><li><code>allcols::Bool = false</code>: Whether to print all columns, rather than a subset that fits the device width.</li><li><code>splitcols::Bool</code>: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block.</li><li><code>rowlabel::Symbol</code>: What label should be printed when rendering the numeric ID's of each row? Defaults to <code>:Row</code>.</li><li><code>displaysummary::Bool</code>: Should a brief string summary of the AbstractDataFrame be rendered to the I/O stream before printing the contents of the renderable rows? Defaults to <code>true</code>.</li><li><code>eltypes::Bool = true</code>: Whether to print the column type  under the column name in the heading. Defaults to <code>true</code>.</li><li><code>rowid::Union{Integer, Nothing} = nothing</code>: Used to handle showing <code>DataFrameRow</code></li><li><code>buffer::IOBuffer</code>: buffer passed around to avoid reallocations in <code>ourstrwidth</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:3, B = ["x", "y", "z"]);

julia&gt; DataFrames.showrows(stdout, df, 1:2, 3:3, [5, 6, 3], false, true, :Row, true)
3×2 DataFrame
│ Row │ A     │ B      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ x      │
│ 2   │ 2     │ y      │
⋮
│ 3   │ 3     │ z      │</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaData/DataFrames.jl/blob/71843b1226f6c8d06121c4e763bf29d8a3da107b/src/abstractdataframe/show.jl#L366-L427" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../indexing/">« Indexing</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 25 August 2020 04:24">Tuesday 25 August 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>